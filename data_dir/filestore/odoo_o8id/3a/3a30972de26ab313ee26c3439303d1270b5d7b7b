)]}'
{"version": 3, "sources": ["/web_tour/static/src/tour_pointer/tour_pointer.js", "/web_tour/static/src/tour_service/tour_compilers.js", "/web_tour/static/src/tour_service/tour_pointer_state.js", "/web_tour/static/src/tour_service/tour_service.js", "/web_tour/static/src/tour_service/tour_state.js", "/web_tour/static/src/tour_service/tour_utils.js", "/web/static/tests/helpers/cleanup.js", "/web/static/tests/helpers/utils.js", "/web/static/tests/utils.js", "/mail/static/tests/tours/discuss_channel_public_tour.js", "/mail/static/tests/tours/discuss_channel_as_guest_tour.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChbA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9LA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5ZA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9oBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5kCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9sBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module **/\n\nimport { Component, useEffect, useRef } from \"@odoo/owl\";\nimport { usePosition } from \"@web/core/position_hook\";\n\n/**\n * @typedef {import(\"../tour_service/tour_pointer_state\").TourPointerState} TourPointerState\n *\n * @typedef TourPointerProps\n * @property {TourPointerState} pointerState\n * @property {boolean} bounce\n */\n\n/** @extends {Component<TourPointerProps, any>} */\nexport class TourPointer extends Component {\n    static props = {\n        pointerState: {\n            type: Object,\n            shape: {\n                anchor: { type: HTMLElement, optional: true },\n                content: { type: String, optional: true },\n                isOpen: { type: Boolean, optional: true },\n                isVisible: { type: Boolean, optional: true },\n                onClick: { type: [Function, { value: null }], optional: true },\n                onMouseEnter: { type: [Function, { value: null }], optional: true },\n                onMouseLeave: { type: [Function, { value: null }], optional: true },\n                position: {\n                    type: [\n                        { value: \"left\" },\n                        { value: \"right\" },\n                        { value: \"top\" },\n                        { value: \"bottom\" },\n                    ],\n                    optional: true,\n                },\n                rev: { type: Number, optional: true },\n            },\n        },\n        bounce: { type: Boolean, optional: true },\n    };\n\n    static defaultProps = {\n        bounce: true,\n    };\n\n    static template = \"web_tour.TourPointer\";\n    static width = 28; // in pixels\n    static height = 28; // in pixels\n\n    setup() {\n        const positionOptions = {\n            margin: 6,\n            onPositioned: (pointer, position) => {\n                const popperRect = pointer.getBoundingClientRect();\n                const { top, left, direction } = position;\n                if (direction === \"top\") {\n                    // position from the bottom instead of the top as it is needed\n                    // to ensure the expand animation is properly done\n                    pointer.style.bottom = `${window.innerHeight - top - popperRect.height}px`;\n                    pointer.style.removeProperty(\"top\");\n                } else if (direction === \"left\") {\n                    // position from the right instead of the left as it is needed\n                    // to ensure the expand animation is properly done\n                    pointer.style.right = `${window.innerWidth - left - popperRect.width}px`;\n                    pointer.style.removeProperty(\"left\");\n                }\n            },\n        };\n        Object.defineProperty(positionOptions, \"position\", { get: () => this.position, enumerable: true });\n        const position = usePosition(\"pointer\", () => this.props.pointerState.anchor, positionOptions);\n        const rootRef = useRef(\"pointer\");\n        /** @type {DOMREct | null} */\n        let dimensions = null;\n        let lastMeasuredContent = null;\n        let lastOpenState = this.isOpen;\n        let lastAnchor;\n        let [anchorX, anchorY] = [0, 0];\n        useEffect(() => {\n            const { el: pointer } = rootRef;\n            if (pointer) {\n                const hasContentChanged = lastMeasuredContent !== this.content;\n                const hasOpenStateChanged = lastOpenState !== this.isOpen;\n                lastOpenState = this.isOpen;\n\n                // Content changed: we must re-measure the dimensions of the text.\n                if (hasContentChanged) {\n                    lastMeasuredContent = this.content;\n                    pointer.style.removeProperty(\"width\");\n                    pointer.style.removeProperty(\"height\");\n                    dimensions = pointer.getBoundingClientRect();\n                }\n\n                // If the content or the \"is open\" state changed: we must apply\n                // new width and height properties\n                if (hasContentChanged || hasOpenStateChanged) {\n                    const [width, height] = this.isOpen\n                        ? [dimensions.width, dimensions.height]\n                        : [this.constructor.width, this.constructor.height];\n                    if (this.isOpen) {\n                        pointer.style.removeProperty(\"transition\");\n                    } else {\n                        // No transition if switching from open to closed\n                        pointer.style.setProperty(\"transition\", \"none\");\n                    }\n                    pointer.style.setProperty(\"width\", `${width}px`);\n                    pointer.style.setProperty(\"height\", `${height}px`);\n                }\n\n                if (!this.isOpen) {\n                    const { anchor } = this.props.pointerState;\n                    if (anchor === lastAnchor) {\n                        const { x, y, width } = anchor.getBoundingClientRect();\n                        const [lastAnchorX, lastAnchorY] = [anchorX, anchorY];\n                        [anchorX, anchorY] = [x, y];\n                        // Let's just say that the anchor is static if it moved less than 1px.\n                        const delta = Math.sqrt(\n                            Math.pow(x - lastAnchorX, 2) + Math.pow(y - lastAnchorY, 2)\n                        );\n                        if (delta < 1) {\n                            position.lock();\n                            return;\n                        }\n                        const wouldOverflow = window.innerWidth - x - width / 2 < dimensions?.width;\n                        pointer.classList.toggle(\"o_expand_left\", wouldOverflow);\n                    }\n                    lastAnchor = anchor;\n                    pointer.style.bottom = \"\";\n                    pointer.style.right = \"\";\n                    position.unlock();\n                }\n            } else {\n                lastMeasuredContent = null;\n                lastOpenState = false;\n                lastAnchor = null;\n                dimensions = null;\n            }\n        });\n    }\n\n    get content() {\n        return this.props.pointerState.content || \"\";\n    }\n\n    get isOpen() {\n        return this.props.pointerState.isOpen;\n    }\n\n    get position() {\n        return this.props.pointerState.position || \"top\";\n    }\n}\n", "/** @odoo-module **/\n\nimport { browser } from \"@web/core/browser/browser\";\nimport { debounce } from \"@web/core/utils/timing\";\nimport { isVisible } from \"@web/core/utils/ui\";\nimport { tourState } from \"./tour_state\";\nimport {\n    callWithUnloadCheck,\n    getConsumeEventType,\n    getFirstVisibleElement,\n    getJQueryElementFromSelector,\n    getScrollParent,\n    RunningTourActionHelper,\n} from \"./tour_utils\";\n\n/**\n * @typedef {import(\"@web/core/macro\").MacroDescriptor} MacroDescriptor\n *\n * @typedef {import(\"../tour_service/tour_pointer_state\").TourPointerState} TourPointerState\n *\n * @typedef {import(\"./tour_service\").TourStep} TourStep\n *\n * @typedef {(stepIndex: number, step: TourStep, options: TourCompilerOptions) => MacroDescriptor[]} TourStepCompiler\n *\n * @typedef TourCompilerOptions\n * @property {Tour} tour\n * @property {number} stepDelay\n * @property {keepWatchBrowser} boolean\n * @property {showPointerDuration} number\n * @property {*} pointer - used for controlling the pointer of the tour\n */\n\n/**\n * @param {string} selector - any valid jquery selector\n * @param {boolean} inModal\n * @param {string|undefined} shadowDOM - selector of the shadow root host\n * @returns {Element | undefined}\n */\nfunction findTrigger(selector, inModal, shadowDOM) {\n    const $target = $(shadowDOM ? document.querySelector(shadowDOM)?.shadowRoot : document);\n    const $visibleModal = $target.find(\".modal:visible\").last();\n    let $el;\n    if (inModal !== false && $visibleModal.length) {\n        $el = $visibleModal.find(selector);\n    } else {\n        $el = getJQueryElementFromSelector(selector, $target);\n    }\n    return getFirstVisibleElement($el).get(0);\n}\n\n/**\n * @param {string|undefined} shadowDOM - selector of the shadow root host\n */\nfunction findExtraTrigger(selector, shadowDOM) {\n    const $target = $(shadowDOM ? document.querySelector(shadowDOM)?.shadowRoot : document);\n    const $el = getJQueryElementFromSelector(selector, $target);\n    return getFirstVisibleElement($el).get(0);\n}\n\nfunction findStepTriggers(step) {\n    const triggerEl = findTrigger(step.trigger, step.in_modal, step.shadow_dom);\n    const altEl = findTrigger(step.alt_trigger, step.in_modal, step.shadow_dom);\n    const skipEl = findTrigger(step.skip_trigger, step.in_modal, step.shadow_dom);\n\n    // `extraTriggerOkay` should be true when `step.extra_trigger` is undefined.\n    // No need for it to be in the modal.\n    const extraTriggerOkay = step.extra_trigger\n        ? findExtraTrigger(step.extra_trigger, step.shadow_dom)\n        : true;\n\n    return { triggerEl, altEl, extraTriggerOkay, skipEl };\n}\n\n/**\n * @param {TourStep} step\n */\nfunction describeStep(step) {\n    return step.content ? `${step.content} (trigger: ${step.trigger})` : step.trigger;\n}\n\n/**\n * @param {TourStep} step\n */\nfunction describeFailedStepSimple(step, tour) {\n    return `Tour ${tour.name} failed at step ${describeStep(step)}`;\n}\n\n/**\n * @param {TourStep} step\n * @param {Tour} tour\n */\nfunction describeFailedStepDetailed(step, tour) {\n    const offset = 3;\n    const stepIndex = tour.steps.findIndex((s) => s === step);\n    const start = stepIndex - offset >= 0 ? stepIndex - offset : 0;\n    const end =\n        stepIndex + offset + 1 <= tour.steps.length ? stepIndex + offset + 1 : tour.steps.length;\n    let result = \"\";\n    for (let i = start; i < end; i++) {\n        const highlight = i === stepIndex;\n        const stepString = JSON.stringify(\n            tour.steps[i],\n            (_key, value) => {\n                if (typeof value === \"function\") {\n                    return \"[function]\";\n                } else {\n                    return value;\n                }\n            },\n            2\n        );\n        result += `\\n${highlight ? \"----- FAILING STEP -----\\n\" : \"\"}${stepString},${\n            highlight ? \"\\n-----------------------\" : \"\"\n        }`;\n    }\n    return `${describeFailedStepSimple(step, tour)}\\n\\n${result.trim()}`;\n}\n\n/**\n * Returns the element that will be used in listening to the `consumeEvent`.\n * @param {HTMLElement} el\n * @param {string} consumeEvent\n */\nfunction getAnchorEl(el, consumeEvent) {\n    if (consumeEvent === \"drag\") {\n        // jQuery-ui draggable triggers 'drag' events on the .ui-draggable element,\n        // but the tip is attached to the .ui-draggable-handle element which may\n        // be one of its children (or the element itself)\n        return el.closest(\".ui-draggable, .o_draggable\");\n    }\n    if (consumeEvent === \"input\" && ![\"textarea\", \"input\"].includes(el.tagName.toLowerCase())) {\n        return el.closest(\"[contenteditable='true']\");\n    }\n    if (consumeEvent === \"sort\") {\n        // when an element is dragged inside a sortable container (with classname\n        // 'ui-sortable'), jQuery triggers the 'sort' event on the container\n        return el.closest(\".ui-sortable, .o_sortable\");\n    }\n    return el;\n}\n\n/**\n * IMPROVEMENT: Consider transitioning (moving) elements?\n * @param {Element} el\n * @param {TourStep} step\n */\nfunction canContinue(el, step) {\n    const rootNode = el.getRootNode();\n    const isInDoc =\n        rootNode instanceof ShadowRoot\n            ? el.ownerDocument.contains(rootNode.host)\n            : el.ownerDocument.contains(el);\n    const isElement = el instanceof el.ownerDocument.defaultView.Element || el instanceof Element;\n    const isBlocked = document.body.classList.contains(\"o_ui_blocked\") || document.querySelector(\".o_blockUI\");\n    return (\n        isInDoc &&\n        isElement &&\n        !isBlocked &&\n        (!step.allowInvisible ? isVisible(el) : true) &&\n        (!el.disabled || step.isCheck)\n    );\n}\n\n/**\n * @param {Object} params\n * @param {HTMLElement} params.anchorEl\n * @param {string} params.consumeEvent\n * @param {() => void} params.onMouseEnter\n * @param {() => void} params.onMouseLeave\n * @param {(ev: Event) => any} params.onScroll\n * @param {(ev: Event) => any} params.onConsume\n */\nfunction setupListeners({\n    anchorEl,\n    consumeEvent,\n    onMouseEnter,\n    onMouseLeave,\n    onScroll,\n    onConsume,\n}) {\n    anchorEl.addEventListener(consumeEvent, onConsume);\n    anchorEl.addEventListener(\"mouseenter\", onMouseEnter);\n    anchorEl.addEventListener(\"mouseleave\", onMouseLeave);\n\n    const cleanups = [\n        () => {\n            anchorEl.removeEventListener(consumeEvent, onConsume);\n            anchorEl.removeEventListener(\"mouseenter\", onMouseEnter);\n            anchorEl.removeEventListener(\"mouseleave\", onMouseLeave);\n        },\n    ];\n\n    const scrollEl = getScrollParent(anchorEl);\n    if (scrollEl) {\n        const debouncedOnScroll = debounce(onScroll, 50);\n        scrollEl.addEventListener(\"scroll\", debouncedOnScroll);\n        cleanups.push(() => scrollEl.removeEventListener(\"scroll\", debouncedOnScroll));\n    }\n\n    return () => {\n        while (cleanups.length) {\n            cleanups.pop()();\n        }\n    };\n}\n\n/** @type {TourStepCompiler} */\nexport function compileStepManual(stepIndex, step, options) {\n    const { tour, pointer, onStepConsummed } = options;\n    let proceedWith = null;\n    let removeListeners = () => {};\n\n    return [\n        {\n            action: () => console.log(step.trigger),\n        },\n        {\n            trigger: () => {\n                removeListeners();\n\n                if (proceedWith) {\n                    return proceedWith;\n                }\n\n                const { triggerEl, altEl, extraTriggerOkay, skipEl } = findStepTriggers(step);\n\n                if (skipEl) {\n                    return skipEl;\n                }\n\n                const stepEl = extraTriggerOkay && (triggerEl || altEl);\n\n                if (stepEl && canContinue(stepEl, step)) {\n                    const consumeEvent = step.consumeEvent || getConsumeEventType(stepEl, step.run);\n                    const anchorEl = getAnchorEl(stepEl, consumeEvent);\n                    const debouncedToggleOpen = debounce(pointer.showContent, 50, true);\n\n                    const updatePointer = () => {\n                        pointer.setState({\n                            onMouseEnter: () => debouncedToggleOpen(true),\n                            onMouseLeave: () => debouncedToggleOpen(false),\n                        });\n                        pointer.pointTo(anchorEl, step);\n                    };\n\n                    removeListeners = setupListeners({\n                        anchorEl,\n                        consumeEvent,\n                        onMouseEnter: () => pointer.showContent(true),\n                        onMouseLeave: () => pointer.showContent(false),\n                        onScroll: updatePointer,\n                        onConsume: () => {\n                            proceedWith = stepEl;\n                            pointer.hide();\n                        },\n                    });\n\n                    updatePointer();\n                } else {\n                    pointer.hide();\n                }\n            },\n            action: () => {\n                tourState.set(tour.name, \"currentIndex\", stepIndex + 1);\n                pointer.hide();\n                proceedWith = null;\n                onStepConsummed(tour, step);\n            },\n        },\n    ];\n}\n\nlet tourTimeout;\n\n/** @type {TourStepCompiler} */\nexport function compileStepAuto(stepIndex, step, options) {\n    const { tour, pointer, stepDelay, keepWatchBrowser, showPointerDuration, onStepConsummed } = options;\n    let skipAction = false;\n    return [\n        {\n            action: async () => {\n                // This delay is important for making the current set of tour tests pass.\n                // IMPROVEMENT: Find a way to remove this delay.\n                await new Promise(resolve => requestAnimationFrame(resolve))\n            },\n        },\n        {\n            action: async () => {\n                skipAction = false;\n                console.log(`Tour ${tour.name} on step: '${describeStep(step)}'`);\n                if (!keepWatchBrowser) {\n                    browser.clearTimeout(tourTimeout);\n                    tourTimeout = browser.setTimeout(() => {\n                        // The logged text shows the relative position of the failed step.\n                        // Useful for finding the failed step.\n                        console.warn(describeFailedStepDetailed(step, tour));\n                        // console.error notifies the test runner that the tour failed.\n                        console.error(describeFailedStepSimple(step, tour));\n                    }, (step.timeout || 10000) + stepDelay);\n                }\n                await new Promise((resolve) => browser.setTimeout(resolve, stepDelay));\n            },\n        },\n        {\n            trigger: () => {\n                const { triggerEl, altEl, extraTriggerOkay, skipEl } = findStepTriggers(step);\n\n                let stepEl = extraTriggerOkay && (triggerEl || altEl);\n\n                if (skipEl) {\n                    skipAction = true;\n                    stepEl = skipEl;\n                }\n\n                if (!stepEl) {\n                    return false;\n                }\n\n                return canContinue(stepEl, step) && stepEl;\n            },\n            action: async (stepEl) => {\n                tourState.set(tour.name, \"currentIndex\", stepIndex + 1);\n\n                if (skipAction) {\n                    return;\n                }\n\n                const consumeEvent = step.consumeEvent || getConsumeEventType(stepEl, step.run);\n                // When in auto mode, we are not waiting for an event to be consumed, so the\n                // anchor is just the step element.\n                const $anchorEl = $(stepEl);\n\n                if (showPointerDuration > 0) {\n                    // Useful in watch mode.\n                    pointer.pointTo($anchorEl.get(0), step);\n                    await new Promise((r) => browser.setTimeout(r, showPointerDuration));\n                    pointer.hide();\n                }\n\n                // TODO: Delegate the following routine to the `ACTION_HELPERS` in the macro module.\n                const actionHelper = new RunningTourActionHelper({\n                    consume_event: consumeEvent,\n                    $anchor: $anchorEl,\n                });\n\n                let result;\n                if (typeof step.run === \"function\") {\n                    const willUnload = await callWithUnloadCheck(() =>\n                        // `this.$anchor` is expected in many `step.run`.\n                        step.run.call({ $anchor: $anchorEl }, actionHelper)\n                    );\n                    result = willUnload && \"will unload\";\n                } else if (step.run !== undefined) {\n                    const m = step.run.match(/^([a-zA-Z0-9_]+) *(?:\\(? *(.+?) *\\)?)?$/);\n                    actionHelper[m[1]](m[2]);\n                } else if (!step.isCheck) {\n                    if (stepIndex === tour.steps.length - 1) {\n                        console.warn('Tour %s: ignoring action (auto) of last step', tour.name);\n                    } else {\n                        actionHelper.auto();\n                    }\n                }\n\n                return result;\n            },\n        },\n        {\n            action: () => {\n                onStepConsummed(tour, step);\n            },\n        },\n    ];\n}\n\n/**\n * @param {import(\"./tour_service\").Tour} tour\n * @param {object} options\n * @param {TourStep[]} options.filteredSteps\n * @param {TourStepCompiler} options.stepCompiler\n * @param {*} options.pointer\n * @param {number} options.stepDelay\n * @param {boolean} options.keepWatchBrowser\n * @param {number} options.showPointerDuration\n * @param {number} options.checkDelay\n * @param {(import(\"./tour_service\").Tour) => void} options.onTourEnd\n */\nexport function compileTourToMacro(tour, options) {\n    const {\n        filteredSteps,\n        stepCompiler,\n        pointer,\n        stepDelay,\n        keepWatchBrowser,\n        showPointerDuration,\n        checkDelay,\n        onStepConsummed,\n        onTourEnd,\n    } = options;\n    const currentStepIndex = tourState.get(tour.name, \"currentIndex\");\n    return {\n        ...tour,\n        checkDelay,\n        steps: filteredSteps\n            .reduce((newSteps, step, i) => {\n                if (i < currentStepIndex) {\n                    // Don't include steps before the current index because they're already done.\n                    return newSteps;\n                } else {\n                    return [\n                        ...newSteps,\n                        ...stepCompiler(i, step, {\n                            tour,\n                            pointer,\n                            stepDelay,\n                            keepWatchBrowser,\n                            showPointerDuration,\n                            onStepConsummed,\n                        }),\n                    ];\n                }\n            }, [])\n            .concat([\n                {\n                    action() {\n                        tourState.clear(tour.name);\n                        onTourEnd(tour);\n                        clearTimeout(tourTimeout);\n                    },\n                },\n            ]),\n    };\n}\n", "/** @odoo-module **/\n\nimport { reactive } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { TourPointer } from \"@web_tour/tour_pointer/tour_pointer\";\nimport { getScrollParent } from \"./tour_utils\";\n\n/**\n * @typedef {import(\"@web/core/position_hook\").Direction} Direction\n *\n * @typedef {\"in\" | \"out-below\" | \"out-above\" | \"unknown\"} IntersectionPosition\n *\n * @typedef {ReturnType<createPointerState>[\"methods\"]} TourPointerMethods\n *\n * @typedef TourPointerState\n * @property {HTMLElement} [anchor]\n * @property {string} [content]\n * @property {boolean} [isOpen]\n * @property {() => {}} [onClick]\n * @property {() => {}} [onMouseEnter]\n * @property {() => {}} [onMouseLeave]\n * @property {boolean} isVisible\n * @property {Direction} position\n * @property {number} rev\n *\n * @typedef {import(\"./tour_service\").TourStep} TourStep\n */\n\nclass Intersection {\n    constructor() {\n        /** @type {Element | null} */\n        this.currentTarget = null;\n        this.rootBounds = null;\n        /** @type {IntersectionPosition} */\n        this._targetPosition = \"unknown\";\n        this._observer = new IntersectionObserver((observations) =>\n            this._handleObservations(observations)\n        );\n    }\n\n    /** @type {IntersectionObserverCallback} */\n    _handleObservations(observations) {\n        if (observations.length < 1) {\n            return;\n        }\n        const observation = observations[observations.length - 1];\n        this.rootBounds = observation.rootBounds;\n        if (this.rootBounds && this.currentTarget) {\n            if (observation.isIntersecting) {\n                this._targetPosition = \"in\";\n            } else {\n                const targetBounds = this.currentTarget.getBoundingClientRect();\n                if (targetBounds.bottom < this.rootBounds.height / 2) {\n                    this._targetPosition = \"out-above\";\n                } else if (targetBounds.top > this.rootBounds.height / 2) {\n                    this._targetPosition = \"out-below\";\n                }\n            }\n        } else {\n            this._targetPosition = \"unknown\";\n        }\n    }\n\n    get targetPosition() {\n        if (!this.rootBounds) {\n            return this.currentTarget ? \"in\" : \"unknown\";\n        } else {\n            return this._targetPosition;\n        }\n    }\n\n    /**\n     * @param {Element} newTarget\n     */\n    setTarget(newTarget) {\n        if (this.currentTarget !== newTarget) {\n            if (this.currentTarget) {\n                this._observer.unobserve(this.currentTarget);\n            }\n            if (newTarget) {\n                this._observer.observe(newTarget);\n            }\n            this.currentTarget = newTarget;\n        }\n    }\n\n    stop() {\n        this._observer.disconnect();\n    }\n}\n\nexport function createPointerState() {\n    /**\n     * @param {Partial<TourPointerState>} newState\n     */\n    const setState = (newState) => {\n        Object.assign(state, newState);\n    };\n\n    /**\n     * @param {TourStep} step\n     * @param {HTMLElement} [anchor]\n     */\n    const pointTo = (anchor, step) => {\n        intersection.setTarget(anchor);\n        if (anchor) {\n            let { position, content } = step;\n            switch (intersection.targetPosition) {\n                case \"unknown\": {\n                    // Do nothing for unknown target position.\n                    break;\n                }\n                case \"in\": {\n                    if (document.body.contains(floatingAnchor)) {\n                        floatingAnchor.remove();\n                    }\n                    setState({ anchor, content, onClick: null, position, isVisible: true });\n                    break;\n                }\n                default: {\n                    const onClick = () => {\n                        anchor.scrollIntoView({ behavior: \"smooth\", block: \"nearest\" });\n                        hide();\n                    };\n\n                    const scrollParent = getScrollParent(anchor);\n                    if (!scrollParent) {\n                        setState({ anchor, content, onClick: null, position, isVisible: true });\n                        return;\n                    }\n                    let { x, y, width, height } = scrollParent.getBoundingClientRect();\n\n                    // If the scrolling element is within an iframe the offsets\n                    // must be computed taking into account the iframe.\n                    const iframeEl = scrollParent.ownerDocument.defaultView.frameElement;\n                    if (iframeEl) {\n                        const iframeOffset = iframeEl.getBoundingClientRect();\n                        x += iframeOffset.x;\n                        y += iframeOffset.y;\n                    }\n                    floatingAnchor.style.left = `${x + width / 2}px`;\n                    if (intersection.targetPosition === \"out-below\") {\n                        position = \"top\";\n                        content = _t(\"Scroll down to reach the next step.\");\n                        floatingAnchor.style.top = `${y + height - TourPointer.height}px`;\n                    } else if (intersection.targetPosition === \"out-above\") {\n                        position = \"bottom\";\n                        content = _t(\"Scroll up to reach the next step.\");\n                        floatingAnchor.style.top = `${y + TourPointer.height}px`;\n                    }\n                    if (!document.contains(floatingAnchor)) {\n                        document.body.appendChild(floatingAnchor);\n                    }\n                    setState({\n                        anchor: floatingAnchor,\n                        content,\n                        onClick,\n                        position,\n                        isVisible: true,\n                    });\n                }\n            }\n        } else {\n            hide();\n        }\n    };\n\n    function hide() {\n        setState({ content: \"\", isVisible: false, isOpen: false });\n    }\n\n    function showContent(isOpen) {\n        setState({ isOpen });\n    }\n\n    function destroy() {\n        intersection.stop();\n        if (document.body.contains(floatingAnchor)) {\n            floatingAnchor.remove();\n        }\n    }\n\n    /** @type {TourPointerState} */\n    const state = reactive({});\n    const intersection = new Intersection();\n    const floatingAnchor = document.createElement(\"div\");\n    floatingAnchor.className = \"position-fixed\";\n\n    return { state, methods: { setState, showContent, pointTo, hide, destroy } };\n}\n", "/** @odoo-module **/\n\nimport { EventBus, markup, whenReady, reactive } from \"@odoo/owl\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { MacroEngine } from \"@web/core/macro\";\nimport { registry } from \"@web/core/registry\";\nimport { config as transitionConfig } from \"@web/core/transition\";\nimport { session } from \"@web/session\";\nimport { TourPointer } from \"../tour_pointer/tour_pointer\";\nimport { compileStepAuto, compileStepManual, compileTourToMacro } from \"./tour_compilers\";\nimport { createPointerState } from \"./tour_pointer_state\";\nimport { tourState } from \"./tour_state\";\nimport { callWithUnloadCheck } from \"./tour_utils\";\n\n/**\n * @typedef {string} JQuerySelector\n * @typedef {import(\"./tour_utils\").RunCommand} RunCommand\n *\n * @typedef Tour\n * @property {string} url\n * @property {string} name\n * @property {() => TourStep[]} steps\n * @property {boolean} [rainbowMan]\n * @property {number} [sequence]\n * @property {boolean} [test]\n * @property {Promise<any>} [wait_for]\n * @property {string} [saveAs]\n * @property {string} [fadeout]\n * @property {number} [checkDelay]\n * @property {string|undefined} [shadow_dom]\n *\n * @typedef TourStep\n * @property {string} [id]\n * @property {JQuerySelector} trigger\n * @property {JQuerySelector} [extra_trigger]\n * @property {JQuerySelector} [alt_trigger]\n * @property {JQuerySelector} [skip_trigger]\n * @property {string} [content]\n * @property {\"top\" | \"botton\" | \"left\" | \"right\"} [position]\n * @property {\"community\" | \"enterprise\"} [edition]\n * @property {RunCommand} [run]\n * @property {boolean} [auto]\n * @property {boolean} [in_modal]\n * @property {number} [width]\n * @property {number} [timeout]\n * @property {boolean} [consumeVisibleOnly]\n * @property {boolean} [noPrepend]\n * @property {string} [consumeEvent]\n * @property {boolean} [mobile]\n * @property {string} [title]\n * @property {string|false|undefined} [shadow_dom]\n *\n * @typedef {\"manual\" | \"auto\"} TourMode\n */\n\nexport const tourService = {\n    // localization dependency to make sure translations used by tours are loaded\n    dependencies: [\"orm\", \"effect\", \"ui\", \"overlay\", \"localization\"],\n    start: async (_env, { orm, effect, ui, overlay }) => {\n        await whenReady();\n        const toursEnabled = \"tour_disable\" in session && !session.tour_disable;\n        const consumedTours = new Set(session.web_tours);\n\n        /** @type {{ [k: string]: Tour }} */\n        const tours = {};\n        const tourRegistry = registry.category(\"web_tour.tours\");\n        function register(name, tour) {\n            name = tour.saveAs || name;\n            const wait_for = tour.wait_for || Promise.resolve();\n            let steps;\n            tours[name] = {\n                wait_for,\n                name,\n                get steps() {\n                    if (typeof tour.steps !== \"function\") {\n                        throw new Error(`tour.steps has to be a function that returns TourStep[]`);\n                    }\n                    if (!steps) {\n                        steps = tour.steps().map((step) => {\n                            step.shadow_dom = step.shadow_dom ?? tour.shadow_dom;\n                            return step;\n                        });\n                    }\n                    return steps;\n                },\n                shadow_dom: tour.shadow_dom,\n                url: tour.url,\n                rainbowMan: tour.rainbowMan === undefined ? true : !!tour.rainbowMan,\n                rainbowManMessage: tour.rainbowManMessage,\n                fadeout: tour.fadeout || \"medium\",\n                sequence: tour.sequence || 1000,\n                test: tour.test,\n                checkDelay: tour.checkDelay,\n            };\n            wait_for.then(() => {\n                if (\n                    !tour.test &&\n                    toursEnabled &&\n                    !consumedTours.has(name) &&\n                    !tourState.getActiveTourNames().includes(name)\n                ) {\n                    startTour(name, { mode: \"manual\", redirect: false });\n                }\n            });\n        }\n        for (const [name, tour] of tourRegistry.getEntries()) {\n            register(name, tour);\n        }\n        tourRegistry.addEventListener(\"UPDATE\", ({ detail: { key, value } }) => {\n            if (tourRegistry.contains(key)) {\n                register(key, value);\n                if (\n                    tourState.getActiveTourNames().includes(key) &&\n                    // Don't resume onboarding tours when tours are disabled\n                    (toursEnabled || tourState.get(key, \"mode\") === \"auto\")\n                ) {\n                    resumeTour(key);\n                }\n            } else {\n                delete tours[value];\n            }\n        });\n\n        const bus = new EventBus();\n        const macroEngine = new MacroEngine({ target: document });\n\n        const pointers = reactive({});\n        /** @type {Set<string>} */\n        const runningTours = new Set();\n\n        // FIXME: this is a hack for stable: whenever the macros advance, for each call to pointTo,\n        // we push a function that will do the pointing as well as the tour name. Then after\n        // a microtask tick, when all pointTo calls have been made by the macro system, we can sort\n        // these by tour priority/sequence and only call the one with the highest priority so we\n        // show the correct pointer.\n        const possiblePointTos = [];\n        function createPointer(tourName, config) {\n            const { state: pointerState, methods } = createPointerState();\n            let remove;\n            return {\n                start() {\n                    pointers[tourName] = {\n                        methods,\n                        id: tourName,\n                        component: TourPointer,\n                        props: { pointerState, ...config },\n                    };\n                    remove = overlay.add(pointers[tourName].component, pointers[tourName].props);\n                },\n                stop() {\n                    remove?.();\n                    delete pointers[tourName];\n                    methods.destroy();\n                },\n                ...methods,\n                async pointTo(anchor, step) {\n                    possiblePointTos.push([tourName, () => methods.pointTo(anchor, step)]);\n                    await Promise.resolve();\n                    // only done once per macro advance\n                    if (!possiblePointTos.length) {\n                        return;\n                    }\n                    const toursByPriority = Object.fromEntries(\n                        getSortedTours().map((t, i) => [t.name, i])\n                    );\n                    const sortedPointTos = possiblePointTos\n                        .slice(0)\n                        .sort(([a], [b]) => toursByPriority[a] - toursByPriority[b]);\n                    possiblePointTos.splice(0); // reset for the next macro advance\n\n                    const active = sortedPointTos[0];\n                    const [activeId, enablePointer] = active || [];\n                    for (const { id, methods } of Object.values(pointers)) {\n                        if (id === activeId) {\n                            enablePointer();\n                        } else {\n                            methods.hide();\n                        }\n                    }\n                },\n            };\n        }\n\n        /**\n         * @param {TourStep} step\n         * @param {TourMode} mode\n         */\n        function shouldOmit(step, mode) {\n            const isDefined = (key, obj) => key in obj && obj[key] !== undefined;\n            const getEdition = () =>\n                (session.server_version_info || []).at(-1) === \"e\" ? \"enterprise\" : \"community\";\n            const correctEdition = isDefined(\"edition\", step)\n                ? step.edition === getEdition()\n                : true;\n            const correctDevice = isDefined(\"mobile\", step) ? step.mobile === ui.isSmall : true;\n            return (\n                !correctEdition ||\n                !correctDevice ||\n                // `step.auto = true` means omitting a step in a manual tour.\n                (mode === \"manual\" && step.auto)\n            );\n        }\n\n        /**\n         * @param {Tour} tour\n         * @param {ReturnType<typeof createPointer>} pointer\n         * @param {Object} options\n         * @param {TourMode} options.mode\n         * @param {number} options.stepDelay\n         * @param {boolean} options.keepWatchBrowser - do not close watch browser when the tour failed\n         * @param {number} options.showPointerDuration\n         * - Useful when watching auto tour.\n         * - Show the pointer for some duration before performing calling the run method.\n         */\n        function convertToMacro(\n            tour,\n            pointer,\n            { mode, stepDelay, keepWatchBrowser, showPointerDuration }\n        ) {\n            // IMPROVEMENTS: Custom step compiler. Will probably require decoupling from `mode`.\n            const stepCompiler = mode === \"auto\" ? compileStepAuto : compileStepManual;\n            const checkDelay = mode === \"auto\" ? tour.checkDelay : 100;\n            const filteredSteps = tour.steps.filter((step) => !shouldOmit(step, mode));\n            return compileTourToMacro(tour, {\n                filteredSteps,\n                stepCompiler,\n                pointer,\n                stepDelay,\n                keepWatchBrowser,\n                showPointerDuration,\n                checkDelay,\n                onStepConsummed(tour, step) {\n                    bus.trigger(\"STEP-CONSUMMED\", { tour, step });\n                },\n                onTourEnd({ name, rainbowManMessage, fadeout }) {\n                    if (mode === \"auto\") {\n                        transitionConfig.disabled = false;\n                    }\n                    let message;\n                    if (typeof rainbowManMessage === \"function\") {\n                        message = rainbowManMessage({\n                            isTourConsumed: (name) => consumedTours.has(name),\n                        });\n                    } else if (typeof rainbowManMessage === \"string\") {\n                        message = rainbowManMessage;\n                    } else {\n                        message = markup(\n                            _t(\n                                \"<strong><b>Good job!</b> You went through all steps of this tour.</strong>\"\n                            )\n                        );\n                    }\n                    effect.add({ type: \"rainbow_man\", message, fadeout });\n                    if (mode === \"manual\") {\n                        consumedTours.add(name);\n                        orm.call(\"web_tour.tour\", \"consume\", [[name]]);\n                    }\n                    pointer.stop();\n                    // Used to signal the python test runner that the tour finished without error.\n                    browser.console.log(\"test successful\");\n                    runningTours.delete(name);\n                },\n            });\n        }\n\n        /**\n         * Wait for the shadow hosts matching the given selectors to\n         * appear in the DOM then, register the underlying shadow roots\n         * to the macro engine observer in order to listen to the\n         * changes in the shadow DOM.\n         *\n         * @param {Set<string>} shadowHostSelectors\n         */\n        function observeShadows(shadowHostSelectors) {\n            const observer = new MutationObserver(() => {\n                const shadowRoots = [];\n                for (const selector of shadowHostSelectors) {\n                    const shadowHost = document.querySelector(selector);\n                    if (shadowHost) {\n                        shadowRoots.push(shadowHost.shadowRoot);\n                        shadowHostSelectors.delete(selector);\n                    }\n                }\n                for (const shadowRoot of shadowRoots) {\n                    macroEngine.observer.observe(shadowRoot, macroEngine.observerOptions);\n                }\n                if (shadowHostSelectors.size === 0) {\n                    observer.disconnect();\n                }\n            });\n            observer.observe(macroEngine.target, { childList: true, subtree: true });\n        }\n\n        /**\n         * Register shadow roots that must be observed by the tour to\n         * the macro engine.\n         *\n         * @param {Tour} tour\n         */\n        function setupShadowObservers(tour) {\n            const shadowDOMs = new Set(\n                tour.steps.filter((step) => step.shadow_dom).map((step) => step.shadow_dom)\n            );\n            if (shadowDOMs.size > 0) {\n                observeShadows(shadowDOMs);\n            }\n        }\n\n        /**\n         * Disable transition before starting an \"auto\" tour.\n         * @param {Macro} macro\n         * @param {'auto' | 'manual'} mode\n         */\n        function activateMacro(macro, mode) {\n            if (mode === \"auto\") {\n                transitionConfig.disabled = true;\n            }\n            macroEngine.activate(macro, mode === \"auto\");\n        }\n\n        function startTour(tourName, options = {}) {\n            if (runningTours.has(tourName) && options.mode === \"manual\") {\n                return;\n            }\n            runningTours.add(tourName);\n            const defaultOptions = {\n                stepDelay: 0,\n                keepWatchBrowser: false,\n                mode: \"auto\",\n                startUrl: \"\",\n                showPointerDuration: 0,\n                redirect: true,\n            };\n            options = Object.assign(defaultOptions, options);\n            const tour = tours[tourName];\n            if (!tour) {\n                throw new Error(`Tour '${tourName}' is not found.`);\n            }\n            tourState.set(tourName, \"currentIndex\", 0);\n            tourState.set(tourName, \"stepDelay\", options.stepDelay);\n            tourState.set(tourName, \"keepWatchBrowser\", options.keepWatchBrowser);\n            tourState.set(tourName, \"showPointerDuration\", options.showPointerDuration);\n            tourState.set(tourName, \"mode\", options.mode);\n            tourState.set(tourName, \"sequence\", tour.sequence);\n            const pointer = createPointer(tourName, {\n                bounce: !(options.mode === \"auto\" && options.keepWatchBrowser),\n            });\n            const macro = convertToMacro(tour, pointer, options);\n            const willUnload = callWithUnloadCheck(() => {\n                if (tour.url && tour.url !== options.startUrl && options.redirect) {\n                    window.location.href = window.location.origin + tour.url;\n                }\n            });\n            if (!willUnload) {\n                setupShadowObservers(tour);\n                pointer.start();\n                activateMacro(macro, options.mode);\n            }\n        }\n\n        function resumeTour(tourName) {\n            if (runningTours.has(tourName)) {\n                return;\n            }\n            runningTours.add(tourName);\n            const tour = tours[tourName];\n            const stepDelay = tourState.get(tourName, \"stepDelay\");\n            const keepWatchBrowser = tourState.get(tourName, \"keepWatchBrowser\");\n            const showPointerDuration = tourState.get(tourName, \"showPointerDuration\");\n            const mode = tourState.get(tourName, \"mode\");\n            const pointer = createPointer(tourName, {\n                bounce: !(mode === \"auto\" && keepWatchBrowser),\n            });\n            const macro = convertToMacro(tour, pointer, {\n                mode,\n                stepDelay,\n                keepWatchBrowser,\n                showPointerDuration,\n            });\n            setupShadowObservers(tour);\n            pointer.start();\n            activateMacro(macro, mode);\n        }\n\n        function getSortedTours() {\n            return Object.values(tours).sort((t1, t2) => {\n                return t1.sequence - t2.sequence || (t1.name < t2.name ? -1 : 1);\n            });\n        }\n\n        if (!window.frameElement) {\n            // Resume running tours.\n            for (const tourName of tourState.getActiveTourNames()) {\n                if (tourName in tours) {\n                    resumeTour(tourName);\n                }\n            }\n        }\n\n        odoo.startTour = startTour;\n        odoo.isTourReady = (tourName) => tours[tourName].wait_for.then(() => true);\n\n        return {\n            bus,\n            startTour,\n            getSortedTours,\n        };\n    },\n};\n\nregistry.category(\"services\").add(\"tour_service\", tourService);\n", "/** @odoo-module **/\n\nimport { browser } from \"@web/core/browser/browser\";\n\nconst BOOLEAN = {\n    toLocalStorage: (val) => (val ? \"1\" : \"0\"),\n    fromLocalStorage: (val) => (val === \"1\" ? true : false),\n};\n\nconst INTEGER = {\n    toLocalStorage: (val) => val.toString(),\n    fromLocalStorage: (val) => parseInt(val, 10),\n};\n\nconst STRING = {\n    toLocalStorage: (x) => x,\n    fromLocalStorage: (x) => x,\n};\n\nconst ALLOWED_KEYS = {\n    // Don't close the 'watch' browser when the tour failed.\n    keepWatchBrowser: BOOLEAN,\n\n    // Duration at which the pointer is shown in auto mode.\n    showPointerDuration: INTEGER,\n\n    // Index of the current step.\n    currentIndex: INTEGER,\n\n    // Global step delay that is specified before starting the tour.\n    stepDelay: INTEGER,\n\n    // 'auto' | 'manual' - important that it's persisted because it's only specified during start of tour.\n    mode: STRING,\n\n    // Used to order the tours.\n    sequence: INTEGER,\n};\n\nfunction getPrefixedName(tourName, key) {\n    return `tour__${tourName}__${key}`;\n}\n\nfunction destructurePrefixedName(prefixedName) {\n    const match = prefixedName.match(/tour__([.\\w]+)__([\\w]+)/);\n    return match ? [match[1], match[2]] : null;\n}\n\n/**\n * Wrapper around localStorage for persistence of the running tours.\n * Useful for resuming running tours when the page refreshed.\n */\nexport const tourState = {\n    get(tourName, key) {\n        if (!(key in ALLOWED_KEYS)) {\n            throw new Error(`Invalid key: '${key}' (tourName = '${tourName}')`);\n        }\n        const prefixedName = getPrefixedName(tourName, key);\n        const savedValue = browser.localStorage.getItem(prefixedName);\n        return ALLOWED_KEYS[key].fromLocalStorage(savedValue);\n    },\n    set(tourName, key, value) {\n        if (!(key in ALLOWED_KEYS)) {\n            throw new Error(`Invalid key: '${key}' (tourName = '${tourName}')`);\n        }\n        const prefixedName = getPrefixedName(tourName, key);\n        browser.localStorage.setItem(prefixedName, ALLOWED_KEYS[key].toLocalStorage(value));\n    },\n    clear(tourName) {\n        for (const key in ALLOWED_KEYS) {\n            const prefixedName = getPrefixedName(tourName, key);\n            browser.localStorage.removeItem(prefixedName);\n        }\n    },\n    getActiveTourNames() {\n        const tourNames = new Set();\n        for (const key of Object.keys(browser.localStorage)) {\n            const [tourName] = destructurePrefixedName(key) || [false];\n            if (tourName) {\n                tourNames.add(tourName);\n            }\n        }\n        return [...tourNames].sort((a, b) => this.get(a, \"sequence\") - this.get(b, \"sequence\"));\n    },\n};\n", "/** @odoo-module **/\n\nimport { markup } from \"@odoo/owl\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { utils } from \"@web/core/ui/ui_service\";\nimport { _legacyIsVisible } from \"@web/core/utils/ui\";\n\n/**\n * @typedef {string | (actions: RunningTourActionHelper) => void | Promise<void>} RunCommand\n */\n\nexport class TourError extends Error {\n    constructor(message, ...args) {\n        super(message, ...args);\n        this.message = `(TourError) ${message}`;\n    }\n}\n\n/**\n * Calls the given `func` then returns/resolves to `true`\n * if it will result to unloading of the page.\n * @param {(...args: any[]) => void} func\n * @param  {any[]} args\n * @returns {boolean | Promise<boolean>}\n */\nexport function callWithUnloadCheck(func, ...args) {\n    let willUnload = false;\n    const beforeunload = () => (willUnload = true);\n    window.addEventListener(\"beforeunload\", beforeunload);\n    const result = func(...args);\n    if (result instanceof Promise) {\n        return result.then(() => {\n            window.removeEventListener(\"beforeunload\", beforeunload);\n            return willUnload;\n        });\n    } else {\n        window.removeEventListener(\"beforeunload\", beforeunload);\n        return willUnload;\n    }\n}\n\nexport function getFirstVisibleElement($elements) {\n    for (var i = 0; i < $elements.length; i++) {\n        var $i = $elements.eq(i);\n        if (_legacyIsVisible($i[0])) {\n            return $i;\n        }\n    }\n    return $();\n}\n\n/**\n * @param {JQuery|undefined} target\n */\nexport function getJQueryElementFromSelector(selector, $target) {\n    $target = $target || $(document);\n    const iframeSplit = typeof selector === \"string\" && selector.match(/(.*\\biframe[^ ]*)(.*)/);\n    if (iframeSplit && iframeSplit[2]) {\n        var $iframe = $target.find(`${iframeSplit[1]}:not(.o_ignore_in_tour)`);\n        if ($iframe.is('[is-ready=\"false\"]')) {\n            return $();\n        }\n        var $el = $iframe.contents().find(iframeSplit[2]);\n        $el.iframeContainer = $iframe[0];\n        return $el;\n    } else if (typeof selector === \"string\") {\n        return $target.find(selector);\n    } else {\n        return $(selector);\n    }\n}\n\n/**\n * @param {HTMLElement} [element]\n * @param {RunCommand} [runCommand]\n * @returns {string}\n */\nexport function getConsumeEventType(element, runCommand) {\n    if (!element) {\n        return \"click\";\n    }\n    const { classList, tagName, type } = element;\n    const tag = tagName.toLowerCase();\n\n    // Many2one\n    if (classList.contains(\"o_field_many2one\")) {\n        return \"autocompleteselect\";\n    }\n\n    // Inputs and textareas\n    if (\n        tag === \"textarea\" ||\n        (tag === \"input\" &&\n            (!type ||\n                [\"email\", \"number\", \"password\", \"search\", \"tel\", \"text\", \"url\"].includes(type)))\n    ) {\n        if (\n            utils.isSmall() &&\n            element.closest(\".o_field_widget\")?.matches(\".o_field_many2one, .o_field_many2many\")\n        ) {\n            return \"click\";\n        }\n        return \"input\";\n    }\n\n    // jQuery draggable\n    if (classList.contains(\"ui-draggable-handle\")) {\n        return \"mousedown\";\n    }\n\n    // Drag & drop run command\n    if (typeof runCommand === \"string\" && /^drag_and_drop/.test(runCommand)) {\n        // this is a heuristic: the element has to be dragged and dropped but it\n        // doesn't have class 'ui-draggable-handle', so we check if it has an\n        // ui-sortable parent, and if so, we conclude that its event type is 'sort'\n        if (element.closest(\".ui-sortable\")) {\n            return \"sort\";\n        }\n        if (\n            (/^drag_and_drop_native/.test(runCommand) && classList.contains(\"o_draggable\")) ||\n            element.closest(\".o_draggable\")\n        ) {\n            return \"pointerdown\";\n        }\n    }\n\n    // Default: click\n    return \"click\";\n}\n\n/**\n * ! This function is a copy-paste of its namesake in web/static/tests/helpers/utils.js\n * TODO: Unify utils for tests and tours since they're doing the exact same thing\n * @param {Node} n1\n * @param {Node} n2\n * @returns {Node[]}\n */\nexport function getDifferentParents(n1, n2) {\n    const parents = [n2];\n    while (parents[0].parentNode) {\n        const parent = parents[0].parentNode;\n        if (parent.contains(n1)) {\n            break;\n        }\n        parents.unshift(parent);\n    }\n    return parents;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {HTMLElement | null}\n */\nexport function getScrollParent(element) {\n    if (!element) {\n        return null;\n    }\n    if (element.scrollHeight > element.clientHeight) {\n        return element;\n    } else {\n        return getScrollParent(element.parentNode);\n    }\n}\n\n/**\n * @param {HTMLElement} el\n * @param {string} type\n * @param {boolean} canBubbleAndBeCanceled\n * @param {PointerEventInit} [additionalParams]\n */\nexport const triggerPointerEvent = (el, type, canBubbleAndBeCanceled, additionalParams) => {\n    const eventInit = {\n        bubbles: canBubbleAndBeCanceled,\n        cancelable: canBubbleAndBeCanceled,\n        view: window,\n        ...additionalParams,\n    };\n\n    el.dispatchEvent(new PointerEvent(type, eventInit));\n    if (type.startsWith(\"pointer\")) {\n        el.dispatchEvent(new MouseEvent(type.replace(\"pointer\", \"mouse\"), eventInit));\n    }\n};\n\nexport class RunningTourActionHelper {\n    constructor(tip_widget) {\n        this.tip_widget = tip_widget;\n    }\n    click(element) {\n        this._click(this._get_action_values(element));\n    }\n    dblclick(element) {\n        this._click(this._get_action_values(element), 2);\n    }\n    tripleclick(element) {\n        this._click(this._get_action_values(element), 3);\n    }\n    clicknoleave(element) {\n        this._click(this._get_action_values(element), 1, false);\n    }\n    text(text, element) {\n        this._text(this._get_action_values(element), text);\n    }\n    remove_text(text, element) {\n        this._text(this._get_action_values(element), \"\\n\");\n    }\n    text_blur(text, element) {\n        this._text_blur(this._get_action_values(element), text);\n    }\n    range(text, element) {\n        this._range(this._get_action_values(element), text);\n    }\n    drag_and_drop(to, element) {\n        this._drag_and_drop_jquery(this._get_action_values(element), to);\n    }\n    drag_and_drop_native(toSel, element) {\n        const to = getJQueryElementFromSelector(toSel)[0];\n        this._drag_and_drop(this._get_action_values(element).$element[0], to);\n    }\n    keydown(keyCodes, element) {\n        this._keydown(this._get_action_values(element), keyCodes.split(/[,\\s]+/));\n    }\n    auto(element) {\n        var values = this._get_action_values(element);\n        if (values.consume_event === \"input\") {\n            this._text(values);\n        } else {\n            this._click(values);\n        }\n    }\n    _get_action_values(element) {\n        var $e = getJQueryElementFromSelector(element);\n        var $element = element ? getFirstVisibleElement($e) : this.tip_widget.$anchor;\n        if ($element.length === 0) {\n            $element = $e.first();\n        }\n        var consume_event = element\n            ? getConsumeEventType($element[0])\n            : this.tip_widget.consume_event;\n        return {\n            $element: $element,\n            consume_event: consume_event,\n        };\n    }\n    _click(values, nb, leave) {\n        const target = values.$element[0];\n        triggerPointerEvent(target, \"pointerover\", true);\n        triggerPointerEvent(target, \"pointerenter\", false);\n        triggerPointerEvent(target, \"pointermove\", true);\n        for (let i = 1; i <= (nb || 1); i++) {\n            triggerPointerEvent(target, \"pointerdown\", true);\n            triggerPointerEvent(target, \"pointerup\", true);\n            triggerPointerEvent(target, \"click\", true, { detail: i });\n            if (i % 2 === 0) {\n                triggerPointerEvent(target, \"dblclick\", true);\n            }\n        }\n        if (leave !== false) {\n            triggerPointerEvent(target, \"pointerout\", true);\n            triggerPointerEvent(target, \"pointerleave\", false);\n        }\n    }\n    _text(values, text) {\n        this._click(values);\n\n        text = text || \"Test\";\n        if (values.consume_event === \"input\") {\n            values.$element\n                .trigger({ type: \"keydown\", key: text[text.length - 1] })\n                .val(text)\n                .trigger({ type: \"keyup\", key: text[text.length - 1] });\n            values.$element[0].dispatchEvent(\n                new InputEvent(\"input\", {\n                    bubbles: true,\n                })\n            );\n        } else if (values.$element.is(\"select\")) {\n            var $options = values.$element.find(\"option\");\n            $options.prop(\"selected\", false).removeProp(\"selected\");\n            var $selectedOption = $options.filter(function () {\n                return $(this).val() === text;\n            });\n            if ($selectedOption.length === 0) {\n                $selectedOption = $options.filter(function () {\n                    return $(this).text().trim() === text;\n                });\n            }\n            const regex = /option\\s+([0-9]+)/;\n            if ($selectedOption.length === 0 && regex.test(text)) {\n                // Extract position as 1-based, as the nth selectors.\n                const position = parseInt(regex.exec(text)[1]);\n                $selectedOption = $options.eq(position - 1); // eq is 0-based.\n            }\n            $selectedOption.prop(\"selected\", true);\n            this._click(values);\n            // For situations where an `oninput` is defined.\n            values.$element.trigger(\"input\");\n        } else {\n            values.$element.focusIn();\n            values.$element.trigger($.Event(\"keydown\", { key: \"_\" }));\n            values.$element.text(text).trigger(\"input\");\n            values.$element.focusInEnd();\n            values.$element.trigger($.Event(\"keyup\", { key: \"_\" }));\n        }\n        values.$element[0].dispatchEvent(new Event(\"change\", { bubbles: true, cancelable: false }));\n    }\n    _text_blur(values, text) {\n        this._text(values, text);\n        values.$element.trigger(\"focusout\");\n        values.$element.trigger(\"blur\");\n    }\n    _range(values, text) {\n        values.$element[0].value = text;\n        values.$element[0].dispatchEvent(new Event('change', { bubbles: true, cancelable: false }));\n    }\n    _calculateCenter($el, selector) {\n        const center = $el.offset();\n        if (selector && selector.indexOf(\"iframe\") !== -1) {\n            const iFrameOffset = $(\"iframe\").offset();\n            center.left += iFrameOffset.left;\n            center.top += iFrameOffset.top;\n        }\n        center.left += $el.outerWidth() / 2;\n        center.top += $el.outerHeight() / 2;\n        return center;\n    }\n    _drag_and_drop_jquery(values, to) {\n        var $to;\n        const elementCenter = this._calculateCenter(values.$element);\n        if (to) {\n            $to = getJQueryElementFromSelector(to);\n        } else {\n            $to = $(document.body);\n        }\n\n        values.$element.trigger($.Event(\"mouseenter\"));\n        // Make the web_studio tour test happy. My guess is that 50%+ of the length of the dragged element\n        // must be situated to the right of the $to element.\n        values.$element.trigger(\n            $.Event(\"mousedown\", {\n                which: 1,\n                pageX: elementCenter.left + 1,\n                pageY: elementCenter.top,\n            })\n        );\n        // Some tests depends on elements present only when the element to drag\n        // start to move while some other tests break while moving.\n        if (!$to.length) {\n            values.$element.trigger(\n                $.Event(\"mousemove\", {\n                    which: 1,\n                    pageX: elementCenter.left + 1,\n                    pageY: elementCenter.top,\n                })\n            );\n            $to = getJQueryElementFromSelector(to);\n        }\n\n        let toCenter = this._calculateCenter($to, to);\n        values.$element.trigger(\n            $.Event(\"mousemove\", { which: 1, pageX: toCenter.left, pageY: toCenter.top })\n        );\n        // Recalculate the center as the mousemove might have made the element bigger.\n        toCenter = this._calculateCenter($to, to);\n        values.$element.trigger(\n            $.Event(\"mouseup\", { which: 1, pageX: toCenter.left, pageY: toCenter.top })\n        );\n    }\n    /**\n     * ! This function is a reduced version of \"drag\" in web/static/tests/helpers/utils.js\n     * TODO: Unify utils for tests and tours since they're doing the exact same thing\n     * @param {HTMLElement} source\n     * @param {HTMLElement} target\n     */\n    _drag_and_drop(source, target) {\n        const sourceRect = source.getBoundingClientRect();\n        const sourcePosition = {\n            clientX: sourceRect.x + sourceRect.width / 2,\n            clientY: sourceRect.y + sourceRect.height / 2,\n        };\n\n        const targetRect = target.getBoundingClientRect();\n        const targetPosition = {\n            clientX: targetRect.x + targetRect.width / 2,\n            clientY: targetRect.y + targetRect.height / 2,\n        };\n\n        triggerPointerEvent(source, \"pointerdown\", true, sourcePosition);\n        triggerPointerEvent(source, \"pointermove\", true, targetPosition);\n\n        for (const parent of getDifferentParents(source, target)) {\n            triggerPointerEvent(parent, \"pointerenter\", false, targetPosition);\n        }\n\n        triggerPointerEvent(target, \"pointerup\", true, targetPosition);\n    }\n    _keydown(values, keyCodes) {\n        while (keyCodes.length) {\n            const eventOptions = {};\n            const keyCode = keyCodes.shift();\n            let insertedText = null;\n            if (isNaN(keyCode)) {\n                eventOptions.key = keyCode;\n            } else {\n                const code = parseInt(keyCode, 10);\n                if (\n                    code === 32 || // spacebar\n                    (code > 47 && code < 58) || // number keys\n                    (code > 64 && code < 91) || // letter keys\n                    (code > 95 && code < 112) || // numpad keys\n                    (code > 185 && code < 193) || // ;=,-./` (in order)\n                    (code > 218 && code < 223) // [\\]' (in order))\n                ) {\n                    insertedText = String.fromCharCode(code);\n                }\n            }\n            values.$element.trigger(Object.assign({ type: \"keydown\" }, eventOptions));\n            if (insertedText) {\n                values.$element[0].ownerDocument.execCommand(\"insertText\", 0, insertedText);\n            }\n            values.$element.trigger(Object.assign({ type: \"keyup\" }, eventOptions));\n        }\n    }\n}\n\nexport const stepUtils = {\n    _getHelpMessage(functionName, ...args) {\n        return `Generated by function tour utils ${functionName}(${args.join(\", \")})`;\n    },\n\n    addDebugHelp(helpMessage, step) {\n        if (typeof step.debugHelp === \"string\") {\n            step.debugHelp = step.debugHelp + \"\\n\" + helpMessage;\n        } else {\n            step.debugHelp = helpMessage;\n        }\n        return step;\n    },\n\n    editionEnterpriseModifier(step) {\n        step.edition = \"enterprise\";\n        return step;\n    },\n\n    mobileModifier(step) {\n        step.mobile = true;\n        return step;\n    },\n\n    showAppsMenuItem() {\n        return {\n            edition: \"community\",\n            trigger: \".o_navbar_apps_menu button\",\n            auto: true,\n            position: \"bottom\",\n        };\n    },\n\n    toggleHomeMenu() {\n        return {\n            edition: \"enterprise\",\n            trigger: \".o_main_navbar .o_menu_toggle\",\n            content: markup(_t(\"Click on the <i>Home icon</i> to navigate across apps.\")),\n            position: \"bottom\",\n        };\n    },\n\n    autoExpandMoreButtons(extra_trigger) {\n        return {\n            trigger: \".o-form-buttonbox\",\n            extra_trigger: extra_trigger,\n            auto: true,\n            run: (actions) => {\n                const $more = $(\".o-form-buttonbox .o_button_more\");\n                if ($more.length) {\n                    actions.click($more);\n                }\n            },\n        };\n    },\n\n    goBackBreadcrumbsMobile(description, ...extraTrigger) {\n        return extraTrigger.map((element) => ({\n            mobile: true,\n            trigger: \".o_back_button\",\n            extra_trigger: element,\n            content: description,\n            position: \"bottom\",\n            debugHelp: this._getHelpMessage(\n                \"goBackBreadcrumbsMobile\",\n                description,\n                ...extraTrigger\n            ),\n        }));\n    },\n\n    goToAppSteps(dataMenuXmlid, description) {\n        return [\n            this.showAppsMenuItem(),\n            {\n                trigger: `.o_app[data-menu-xmlid=\"${dataMenuXmlid}\"]`,\n                content: description,\n                position: \"right\",\n                edition: \"community\",\n            },\n            {\n                trigger: `.o_app[data-menu-xmlid=\"${dataMenuXmlid}\"]`,\n                content: description,\n                position: \"bottom\",\n                edition: \"enterprise\",\n            },\n        ].map((step) =>\n            this.addDebugHelp(this._getHelpMessage(\"goToApp\", dataMenuXmlid, description), step)\n        );\n    },\n\n    openBurgerMenu(extraTrigger) {\n        return {\n            mobile: true,\n            trigger: \".o_mobile_menu_toggle\",\n            extra_trigger: extraTrigger,\n            content: _t(\"Open bugger menu.\"),\n            position: \"bottom\",\n            debugHelp: this._getHelpMessage(\"openBurgerMenu\", extraTrigger),\n        };\n    },\n\n    statusbarButtonsSteps(innerTextButton, description, extraTrigger) {\n        return [\n            {\n                mobile: true,\n                auto: true,\n                trigger: \".o_statusbar_buttons\",\n                extra_trigger: extraTrigger,\n                run: (actions) => {\n                    const $action = $(\".o_statusbar_buttons .btn.dropdown-toggle:contains(Action)\");\n                    if ($action.length) {\n                        actions.click($action);\n                    }\n                },\n            },\n            {\n                trigger: `.o_statusbar_buttons button:enabled:contains('${innerTextButton}')`,\n                content: description,\n                position: \"bottom\",\n            },\n        ].map((step) =>\n            this.addDebugHelp(\n                this._getHelpMessage(\n                    \"statusbarButtonsSteps\",\n                    innerTextButton,\n                    description,\n                    extraTrigger\n                ),\n                step\n            )\n        );\n    },\n\n    simulateEnterKeyboardInSearchModal() {\n        return {\n            mobile: true,\n            trigger: \".o_searchview_input\",\n            extra_trigger: \".modal:not(.o_inactive_modal) .dropdown-menu.o_searchview_autocomplete\",\n            position: \"bottom\",\n            run: (action) => {\n                const keyEventEnter = new KeyboardEvent(\"keydown\", {\n                    bubbles: true,\n                    cancelable: true,\n                    key: \"Enter\",\n                    code: \"Enter\",\n                });\n                action.tip_widget.$anchor[0].dispatchEvent(keyEventEnter);\n            },\n            debugHelp: this._getHelpMessage(\"simulateEnterKeyboardInSearchModal\"),\n        };\n    },\n\n    mobileKanbanSearchMany2X(modalTitle, valueSearched) {\n        return [\n            {\n                mobile: true,\n                trigger: `.o_control_panel_navigation .btn .fa-search`,\n                position: \"bottom\",\n            },\n            {\n                mobile: true,\n                trigger: \".o_searchview_input\",\n                extra_trigger: `.modal:not(.o_inactive_modal) .modal-title:contains('${modalTitle}')`,\n                position: \"bottom\",\n                run: `text ${valueSearched}`,\n            },\n            this.simulateEnterKeyboardInSearchModal(),\n            {\n                mobile: true,\n                trigger: `.o_kanban_record .o_kanban_record_title :contains('${valueSearched}')`,\n                position: \"bottom\",\n            },\n        ].map((step) =>\n            this.addDebugHelp(\n                this._getHelpMessage(\"mobileKanbanSearchMany2X\", modalTitle, valueSearched),\n                step\n            )\n        );\n    },\n    /**\n     * Utility steps to save a form and wait for the save to complete\n     *\n     * @param {object} [options]\n     * @param {string} [options.content]\n     * @param {string} [options.extra_trigger] additional save-condition selector\n     */\n    saveForm(options = {}) {\n        return [\n            {\n                content: options.content || \"save form\",\n                trigger: \".o_form_button_save\",\n                extra_trigger: options.extra_trigger,\n                run: \"click\",\n                auto: true,\n            },\n            {\n                content: \"wait for save completion\",\n                trigger: \".o_form_readonly, .o_form_saved\",\n                run() {},\n                auto: true,\n            },\n        ];\n    },\n    /**\n     * Utility steps to cancel a form creation or edition.\n     *\n     * Supports creation/edition from either a form or a list view (so checks\n     * for both states).\n     */\n    discardForm(options = {}) {\n        return [\n            {\n                content: options.content || \"exit the form\",\n                trigger: \".o_form_button_cancel\",\n                extra_trigger: options.extra_trigger,\n                run: \"click\",\n                auto: true,\n            },\n            {\n                content: \"wait for cancellation to complete\",\n                trigger:\n                    \".o_view_controller.o_list_view, .o_form_view > div > div > .o_form_readonly, .o_form_view > div > div > .o_form_saved\",\n                run() {},\n                auto: true,\n            },\n        ];\n    },\n};\n", "/** @odoo-module **/\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\nconst cleanups = [];\n\n/**\n * Register a cleanup callback that will be executed whenever the current test\n * is done.\n *\n * - the cleanups will be executed in reverse order\n * - they will be executed even if the test fails/crashes\n *\n * @param {Function} callback\n */\nexport function registerCleanup(callback) {\n    cleanups.push(callback);\n}\n\nif (window.QUnit) {\n    QUnit.on(\"OdooAfterTestHook\", (info) => {\n        if (QUnit.config.debug) {\n            return;\n        }\n        let cleanup;\n        // note that this calls the cleanup callbacks in reverse order!\n        while ((cleanup = cleanups.pop())) {\n            try {\n                cleanup(info);\n            } catch (error) {\n                console.error(error);\n            }\n        }\n    });\n\n    // -----------------------------------------------------------------------------\n    // Check leftovers\n    // -----------------------------------------------------------------------------\n\n    /**\n     * List of elements tolerated in the body after a test. The property \"keep\"\n     * prevents the element from being removed (typically: qunit suite elements).\n     */\n    const validElements = [\n        // always in the body:\n        { tagName: \"DIV\", attr: \"id\", value: \"qunit\", keep: true },\n        { tagName: \"DIV\", attr: \"id\", value: \"qunit-fixture\", keep: true },\n        // shouldn't be in the body after a test but are tolerated:\n        { tagName: \"SCRIPT\", attr: \"id\", value: \"\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"o_notification_manager\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip fade bs-tooltip-auto\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip fade bs-tooltip-auto show\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip tooltip-field-info fade bs-tooltip-auto\" },\n        {\n            tagName: \"DIV\",\n            attr: \"class\",\n            value: \"tooltip tooltip-field-info fade bs-tooltip-auto show\",\n        },\n        { tagName: \"SPAN\", attr: \"class\", value: \"select2-hidden-accessible\" },\n\n        // Due to a Document Kanban bug (already present in 12.0)\n        { tagName: \"DIV\", attr: \"class\", value: \"ui-helper-hidden-accessible\" },\n        {\n            tagName: \"UL\",\n            attr: \"class\",\n            value: \"ui-menu ui-widget ui-widget-content ui-autocomplete ui-front\",\n        },\n        {\n            tagName: \"UL\",\n            attr: \"class\",\n            value: \"ui-menu ui-widget ui-widget-content ui-autocomplete dropdown-menu ui-front\", // many2ones\n        },\n    ];\n\n    /**\n     * After each test, we check that there is no leftover in the DOM.\n     *\n     * Note: this event is not QUnit standard, we added it for this specific use case.\n     * As a payload, an object with keys 'moduleName' and 'testName' is provided. It\n     * is used to indicate the test that left elements in the DOM, when it happens.\n     */\n    QUnit.on(\"OdooAfterTestHook\", function (info) {\n        if (QUnit.config.debug) {\n            return;\n        }\n        const failed = info.testReport.getStatus() === \"failed\";\n        const toRemove = [];\n        // check for leftover elements in the body\n        for (const bodyChild of document.body.children) {\n            const tolerated = validElements.find(\n                (e) => e.tagName === bodyChild.tagName && bodyChild.getAttribute(e.attr) === e.value\n            );\n            if (!failed && !tolerated) {\n                QUnit.pushFailure(\n                    `Body still contains undesirable elements:\\n${bodyChild.outerHTML}`\n                );\n            }\n            if (!tolerated || !tolerated.keep) {\n                toRemove.push(bodyChild);\n            }\n        }\n        // cleanup leftovers in #qunit-fixture\n        const qunitFixture = document.getElementById(\"qunit-fixture\");\n        if (qunitFixture.children.length) {\n            toRemove.push(...qunitFixture.children);\n        }\n        // remove unwanted elements if not in debug\n        for (const el of toRemove) {\n            el.remove();\n        }\n        document.body.classList.remove(\"modal-open\");\n    });\n}\n", "/** @odoo-module **/\n\nimport { templates } from \"@web/core/assets\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { isMacOS } from \"@web/core/browser/feature_detection\";\nimport { download } from \"@web/core/network/download\";\nimport { Deferred } from \"@web/core/utils/concurrency\";\nimport { patch } from \"@web/core/utils/patch\";\nimport { isVisible } from \"@web/core/utils/ui\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { registerCleanup } from \"./cleanup\";\n\nimport {\n    App,\n    onError,\n    onMounted,\n    onPatched,\n    onRendered,\n    onWillDestroy,\n    onWillPatch,\n    onWillRender,\n    onWillStart,\n    onWillUnmount,\n    onWillUpdateProps,\n    useComponent,\n} from \"@odoo/owl\";\n\n/**\n * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType\n *\n * @typedef {Side | `${Side}-${Side}` | { x?: number, y?: number }} Position\n *\n * @typedef {\"bottom\" | \"left\" | \"right\" | \"top\"} Side\n *\n * @typedef TriggerEventOptions\n * @property {boolean} [skipVisibilityCheck=false]\n * @property {boolean} [sync=false]\n */\n\n/**\n * Patch the native Date object\n *\n * Note that it will be automatically unpatched at the end of the test\n *\n * @param {number} [year]\n * @param {number} [month]\n * @param {number} [day]\n * @param {number} [hours]\n * @param {number} [minutes]\n * @param {number} [seconds]\n * @param {number} [ms=0]\n */\nexport function patchDate(year, month, day, hours, minutes, seconds, ms = 0) {\n    var RealDate = window.Date;\n    var actualDate = new RealDate();\n\n    // By default, RealDate uses the browser offset, so we must replace it with the offset fixed in luxon.\n    var fakeDate = new RealDate(year, month, day, hours, minutes, seconds, ms);\n    if (!(luxon.Settings.defaultZone instanceof luxon.FixedOffsetZone)) {\n        throw new Error(\"luxon.Settings.defaultZone must be a FixedOffsetZone\");\n    }\n    const browserOffset = -fakeDate.getTimezoneOffset();\n    const patchedOffset = luxon.Settings.defaultZone.offset();\n    const offsetDiff = patchedOffset - browserOffset;\n    const correctedMinutes = fakeDate.getMinutes() - offsetDiff;\n    fakeDate.setMinutes(correctedMinutes);\n\n    var timeInterval = actualDate.getTime() - fakeDate.getTime();\n\n    // eslint-disable-next-line no-global-assign\n    window.Date = (function (NativeDate) {\n        function Date(Y, M, D, h, m, s, ms) {\n            var length = arguments.length;\n            let date;\n            if (arguments.length > 0) {\n                date =\n                    length == 1 && String(Y) === Y // isString(Y)\n                        ? // We explicitly pass it through parse:\n                          new NativeDate(Date.parse(Y))\n                        : // We have to manually make calls depending on argument\n                        // length here\n                        length >= 7\n                        ? new NativeDate(Y, M, D, h, m, s, ms)\n                        : length >= 6\n                        ? new NativeDate(Y, M, D, h, m, s)\n                        : length >= 5\n                        ? new NativeDate(Y, M, D, h, m)\n                        : length >= 4\n                        ? new NativeDate(Y, M, D, h)\n                        : length >= 3\n                        ? new NativeDate(Y, M, D)\n                        : length >= 2\n                        ? new NativeDate(Y, M)\n                        : length >= 1\n                        ? new NativeDate(Y)\n                        : new NativeDate();\n                // Prevent mixups with unfixed Date object\n                date.constructor = Date;\n                return date;\n            } else {\n                date = new NativeDate();\n                var time = date.getTime();\n                time -= timeInterval;\n                date.setTime(time);\n                return date;\n            }\n        }\n\n        // Copy any custom methods a 3rd party library may have added\n        for (var key in NativeDate) {\n            Date[key] = NativeDate[key];\n        }\n\n        // Copy \"native\" methods explicitly; they may be non-enumerable\n        // exception: 'now' uses fake date as reference\n        Date.now = function () {\n            var date = new NativeDate();\n            var time = date.getTime();\n            time -= timeInterval;\n            return time;\n        };\n        Date.UTC = NativeDate.UTC;\n        Date.prototype = NativeDate.prototype;\n        Date.prototype.constructor = Date;\n\n        // Upgrade Date.parse to handle simplified ISO 8601 strings\n        Date.parse = NativeDate.parse;\n        return Date;\n    })(Date);\n\n    registerCleanup(() => {\n        window.Date = RealDate;\n    });\n}\n\n/**\n * Applies a fixed time zone to luxon based on an offset to the UTC time zone.\n *\n * @param {number} offset the number of minutes ahead or behind the UTC time zone\n *                          +120 => UTC+2\n *                          -120 => UTC-2\n */\nexport function patchTimeZone(offset) {\n    patchWithCleanup(luxon.Settings, { defaultZone: luxon.FixedOffsetZone.instance(offset) });\n}\n\n/**\n *\n * @param {Object} obj object to patch\n * @param {Object} patchValue the actual patch description\n */\nexport function patchWithCleanup(obj, patchValue) {\n    const unpatch = patch(obj, patchValue);\n    registerCleanup(() => {\n        unpatch();\n    });\n}\n\n/**\n * @returns {Element}\n */\nexport function getFixture() {\n    if (!window.QUnit) {\n        return document;\n    }\n    if (QUnit.config.debug) {\n        return document.body;\n    } else {\n        return document.getElementById(\"qunit-fixture\");\n    }\n}\n\nexport async function nextTick() {\n    await new Promise((resolve) => window.requestAnimationFrame(resolve));\n    await new Promise((resolve) => setTimeout(resolve));\n}\n\nexport function makeDeferred() {\n    return new Deferred();\n}\n\nexport function findElement(el, selector) {\n    let target = el;\n    if (selector) {\n        const els = el.querySelectorAll(selector);\n        if (els.length === 0) {\n            throw new Error(`No element found (selector: ${selector})`);\n        }\n        if (els.length > 1) {\n            throw new Error(`Found ${els.length} elements, instead of 1 (selector: ${selector})`);\n        }\n        target = els[0];\n    }\n    return target;\n}\n\n//-----------------------------------------------------------------------------\n// Event init attributes mappers\n//-----------------------------------------------------------------------------\n\n/** @param {EventInit} [args] */\nconst mapBubblingEvent = (args) => ({ ...args, bubbles: true });\n\n/** @param {EventInit} [args] */\nconst mapNonBubblingEvent = (args) => ({ ...args, bubbles: false });\n\n/** @param {EventInit} [args={}] */\nconst mapBubblingPointerEvent = (args = {}) => ({\n    clientX: args.pageX,\n    clientY: args.pageY,\n    ...args,\n    bubbles: true,\n    cancelable: true,\n    view: window,\n});\n\n/** @param {EventInit} [args] */\nconst mapNonBubblingPointerEvent = (args) => ({\n    ...mapBubblingPointerEvent(args),\n    bubbles: false,\n    cancelable: false,\n});\n\n/** @param {EventInit} [args={}] */\nconst mapCancelableTouchEvent = (args = {}) => ({\n    ...args,\n    bubbles: true,\n    cancelable: true,\n    composed: true,\n    rotation: 0.0,\n    touches: args.touches ? [...args.touches.map((e) => new Touch(e))] : undefined,\n    view: window,\n    zoom: 1.0,\n});\n\n/** @param {EventInit} [args] */\nconst mapNonCancelableTouchEvent = (args) => ({\n    ...mapCancelableTouchEvent(args),\n    cancelable: false,\n});\n\n/** @param {EventInit} [args] */\nconst mapKeyboardEvent = (args) => ({\n    ...args,\n    bubbles: true,\n    cancelable: true,\n});\n\n/**\n * @template {typeof Event} T\n * @param {EventType} eventType\n * @returns {[T, (attrs: EventInit) => EventInit]}\n */\nconst getEventConstructor = (eventType) => {\n    switch (eventType) {\n        // Mouse events\n        case \"auxclick\":\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"mousedown\":\n        case \"mouseup\":\n        case \"mousemove\":\n        case \"mouseover\":\n        case \"mouseout\": {\n            return [MouseEvent, mapBubblingPointerEvent];\n        }\n        case \"mouseenter\":\n        case \"mouseleave\": {\n            return [MouseEvent, mapNonBubblingPointerEvent];\n        }\n        // Pointer events\n        case \"pointerdown\":\n        case \"pointerup\":\n        case \"pointermove\":\n        case \"pointerover\":\n        case \"pointerout\": {\n            return [PointerEvent, mapBubblingPointerEvent];\n        }\n        case \"pointerenter\":\n        case \"pointerleave\": {\n            return [PointerEvent, mapNonBubblingPointerEvent];\n        }\n        // Focus events\n        case \"focusin\": {\n            return [FocusEvent, mapBubblingEvent];\n        }\n        case \"focus\":\n        case \"blur\": {\n            return [FocusEvent, mapNonBubblingEvent];\n        }\n        // Clipboard events\n        case \"cut\":\n        case \"copy\":\n        case \"paste\": {\n            return [ClipboardEvent, mapBubblingEvent];\n        }\n        // Keyboard events\n        case \"keydown\":\n        case \"keypress\":\n        case \"keyup\": {\n            return [KeyboardEvent, mapKeyboardEvent];\n        }\n        // Drag events\n        case \"drag\":\n        case \"dragend\":\n        case \"dragenter\":\n        case \"dragstart\":\n        case \"dragleave\":\n        case \"dragover\":\n        case \"drop\": {\n            return [DragEvent, mapBubblingEvent];\n        }\n        // Input events\n        case \"input\": {\n            return [InputEvent, mapBubblingEvent];\n        }\n        // Composition events\n        case \"compositionstart\":\n        case \"compositionend\": {\n            return [CompositionEvent, mapBubblingEvent];\n        }\n        // UI events\n        case \"scroll\": {\n            return [UIEvent, mapNonBubblingEvent];\n        }\n        // Touch events\n        case \"touchstart\":\n        case \"touchend\":\n        case \"touchmove\": {\n            return [TouchEvent, mapCancelableTouchEvent];\n        }\n        case \"touchcancel\": {\n            return [TouchEvent, mapNonCancelableTouchEvent];\n        }\n        // Default: base Event constructor\n        default: {\n            return [Event, mapBubblingEvent];\n        }\n    }\n};\n\n/**\n * @template {EventType} T\n * @param {Element} el\n * @param {string | null | undefined | false} selector\n * @param {T} eventType\n * @param {EventInit} [eventInit]\n * @param {TriggerEventOptions} [options={}]\n * @returns {GlobalEventHandlersEventMap[T] | Promise<GlobalEventHandlersEventMap[T]>}\n */\nexport function triggerEvent(el, selector, eventType, eventInit, options = {}) {\n    const errors = [];\n    const target = findElement(el, selector);\n\n    // Error handling\n    if (typeof eventType !== \"string\") {\n        errors.push(\"event type must be a string\");\n    }\n    if (!target) {\n        errors.push(\"cannot find target\");\n    } else if (!options.skipVisibilityCheck && !isVisible(target)) {\n        errors.push(\"target is not visible\");\n    }\n    if (errors.length) {\n        throw new Error(\n            `Cannot trigger event${eventType ? ` \"${eventType}\"` : \"\"}${\n                selector ? ` (with selector \"${selector}\")` : \"\"\n            }: ${errors.join(\" and \")}`\n        );\n    }\n\n    // Actual dispatch\n    const [Constructor, processParams] = getEventConstructor(eventType);\n    const event = new Constructor(eventType, processParams(eventInit));\n    target.dispatchEvent(event);\n\n    if (window.QUnit && QUnit.config.debug) {\n        const group = `%c[${event.type.toUpperCase()}]`;\n        console.groupCollapsed(group, \"color: #b52c9b\");\n        console.log(target, event);\n        console.groupEnd(group, \"color: #b52c9b\");\n    }\n\n    if (options.sync) {\n        return event;\n    } else {\n        return nextTick().then(() => event);\n    }\n}\n\n/**\n * @param {Element} el\n * @param {string | null | undefined | false} selector\n * @param {(EventType | [EventType, EventInit])[]} [eventDefs]\n * @param {TriggerEventOptions} [options={}]\n */\nexport function triggerEvents(el, selector, eventDefs, options = {}) {\n    const events = [...eventDefs].map((eventDef) => {\n        const [eventType, eventInit] = Array.isArray(eventDef) ? eventDef : [eventDef, {}];\n        return triggerEvent(el, selector, eventType, eventInit, options);\n    });\n    if (options.sync) {\n        return events;\n    } else {\n        return nextTick().then(() => events);\n    }\n}\n\n/**\n * Triggers a scroll event on the given target\n *\n * If the target cannot be scrolled or an axis has reached\n * the end of the scrollable area, the event can be transmitted\n * to its nearest parent until it can be triggered\n *\n * @param {Element} target target of the scroll event\n * @param {Object} coordinates\n * @param {number} coordinates.left coordinates to scroll horizontally\n * @param {number} coordinates.top coordinates to scroll vertically\n * @param {boolean} canPropagate states if the scroll can propagate to a scrollable parent\n */\nexport async function triggerScroll(\n    target,\n    coordinates = { left: null, top: null },\n    canPropagate = true\n) {\n    const isScrollable =\n        (target.scrollHeight > target.clientHeight && target.clientHeight > 0) ||\n        (target.scrollWidth > target.clientWidth && target.clientWidth > 0);\n    if (!isScrollable && !canPropagate) {\n        return;\n    }\n    if (isScrollable) {\n        const canScrollFrom = {\n            left:\n                coordinates.left > target.scrollLeft\n                    ? target.scrollLeft + target.clientWidth < target.scrollWidth\n                    : target.scrollLeft > 0,\n            top:\n                coordinates.top > target.scrollTop\n                    ? target.scrollTop + target.clientHeight < target.scrollHeight\n                    : target.scrollTop > 0,\n        };\n        const scrollCoordinates = {};\n        Object.entries(coordinates).forEach(([key, value]) => {\n            if (value !== null && canScrollFrom[key]) {\n                scrollCoordinates[key] = value;\n                delete coordinates[key];\n            }\n        });\n        target.scrollTo(scrollCoordinates);\n        await triggerEvent(target, null, \"scroll\");\n        if (!canPropagate || !Object.entries(coordinates).length) {\n            return;\n        }\n    }\n    target.parentElement\n        ? triggerScroll(target.parentElement, coordinates)\n        : triggerEvent(window, null, \"scroll\");\n    await nextTick();\n}\n\nexport function click(\n    el,\n    selector,\n    { mouseEventInit = {}, skipDisabledCheck = false, skipVisibilityCheck = false } = {}\n) {\n    if (!skipDisabledCheck && el.disabled) {\n        throw new Error(\"Can't click on a disabled button\");\n    }\n    return triggerEvents(\n        el,\n        selector,\n        [\"pointerdown\", \"mousedown\", \"focus\", \"pointerup\", \"mouseup\", [\"click\", mouseEventInit]],\n        { skipVisibilityCheck }\n    );\n}\n\nexport function clickCreate(htmlElement) {\n    if (\n        htmlElement.querySelectorAll(\n            \".o_control_panel_main_buttons .d-none.d-xl-inline-flex .o_form_button_create\"\n        ).length\n    ) {\n        return click(\n            htmlElement,\n            \".o_control_panel_main_buttons .d-none.d-xl-inline-flex .o_form_button_create\"\n        );\n    } else if (\n        htmlElement.querySelectorAll(\n            \".o_control_panel_main_buttons .d-none.d-xl-inline-flex .o_list_button_create\"\n        ).length\n    ) {\n        return click(\n            htmlElement,\n            \".o_control_panel_main_buttons .d-none.d-xl-inline-flex .o_list_button_create\"\n        );\n    } else {\n        throw new Error(\"No edit button found to be clicked.\");\n    }\n}\n\nexport function clickEdit(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_list_button_edit\").length) {\n        return click(htmlElement, \".o_list_button_edit\");\n    } else {\n        throw new Error(\"No edit button found to be clicked.\");\n    }\n}\n\nexport async function clickSave(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_form_status_indicator\").length) {\n        await mouseEnter(htmlElement, \".o_form_status_indicator\");\n    }\n    if (htmlElement.querySelectorAll(\".o_form_button_save\").length) {\n        return click(htmlElement, \".o_form_button_save\");\n    }\n    const listSaveButtons = htmlElement.querySelectorAll(\".o_list_button_save\");\n    if (listSaveButtons.length) {\n        return listSaveButtons.length >= 2 ? click(listSaveButtons[1]) : click(listSaveButtons[0]);\n    } else {\n        throw new Error(\"No save button found to be clicked.\");\n    }\n}\n\nexport async function clickDiscard(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_form_status_indicator\").length) {\n        await mouseEnter(htmlElement, \".o_form_status_indicator\");\n    }\n    if (htmlElement.querySelectorAll(\".o_form_button_cancel\").length) {\n        return click(htmlElement, \".o_form_button_cancel\");\n    } else if ($(htmlElement).find(\".o_list_button_discard:visible\").length) {\n        return click($(htmlElement).find(\".o_list_button_discard:visible\").get(0));\n    } else {\n        throw new Error(\"No discard button found to be clicked.\");\n    }\n}\n\n/**\n * Trigger pointerenter and mouseenter events on the given target. If no\n * coordinates are given, the event is located by default\n * in the middle of the target to simplify the test process\n *\n * @param {Element} el\n * @param {string} selector\n * @param {Object} coordinates position of the mouseenter event\n */\nexport async function mouseEnter(el, selector, coordinates) {\n    const target = el.querySelector(selector) || el;\n    const atPos = coordinates || {\n        clientX: target.getBoundingClientRect().left + target.getBoundingClientRect().width / 2,\n        clientY: target.getBoundingClientRect().top + target.getBoundingClientRect().height / 2,\n    };\n    return triggerEvents(target, null, [\"pointerenter\", \"mouseenter\"], atPos);\n}\n\n/**\n * Trigger pointerleave and mouseleave events on the given target.\n *\n * @param {Element} el\n * @param {string} selector\n */\nexport async function mouseLeave(el, selector) {\n    const target = el.querySelector(selector) || el;\n    return triggerEvents(target, null, [\"pointerleave\", \"mouseleave\"]);\n}\n\nexport async function editInput(el, selector, value) {\n    const input = findElement(el, selector);\n    if (!(input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) {\n        throw new Error(\"Only 'input' and 'textarea' elements can be edited with 'editInput'.\");\n    }\n    if (\n        ![\"text\", \"textarea\", \"email\", \"search\", \"color\", \"number\", \"file\", \"tel\"].includes(\n            input.type\n        )\n    ) {\n        throw new Error(`Type \"${input.type}\" not supported by 'editInput'.`);\n    }\n\n    const eventOpts = {};\n    if (input.type === \"file\") {\n        const files = Array.isArray(value) ? value : [value];\n        const dataTransfer = new DataTransfer();\n        for (const file of files) {\n            if (!(file instanceof File)) {\n                throw new Error(`File input value should be one or several File objects.`);\n            }\n            dataTransfer.items.add(file);\n        }\n        input.files = dataTransfer.files;\n        eventOpts.skipVisibilityCheck = true;\n    } else {\n        input.value = value;\n    }\n\n    await triggerEvents(input, null, [\"input\", \"change\"], eventOpts);\n\n    if (input.type === \"file\") {\n        // Need to wait for the file to be loaded by the input\n        await nextTick();\n        await nextTick();\n    }\n}\n\nexport function editSelect(el, selector, value) {\n    const select = findElement(el, selector);\n    if (select.tagName !== \"SELECT\") {\n        throw new Error(\"Only select tag can be edited with selectInput.\");\n    }\n    select.value = value;\n    return triggerEvent(select, null, \"change\");\n}\n\nexport async function editSelectMenu(el, selector, value) {\n    const dropdown = el.querySelector(selector);\n    await click(dropdown.querySelector(\".dropdown-toggle\"));\n    for (const item of Array.from(dropdown.querySelectorAll(\".dropdown-item\"))) {\n        if (item.textContent === value) {\n            return click(item);\n        }\n    }\n}\n\n/**\n * Triggers an hotkey properly disregarding the operating system.\n *\n * @param {string} hotkey\n * @param {boolean} addOverlayModParts\n * @param {KeyboardEventInit} eventAttrs\n */\nexport async function triggerHotkey(hotkey, addOverlayModParts = false, eventAttrs = {}) {\n    eventAttrs.key = hotkey.split(\"+\").pop();\n\n    if (/shift/i.test(hotkey)) {\n        eventAttrs.shiftKey = true;\n    }\n\n    if (/control/i.test(hotkey)) {\n        if (isMacOS()) {\n            eventAttrs.metaKey = true;\n        } else {\n            eventAttrs.ctrlKey = true;\n        }\n    }\n\n    if (/alt/i.test(hotkey) || addOverlayModParts) {\n        if (isMacOS()) {\n            eventAttrs.ctrlKey = true;\n        } else {\n            eventAttrs.altKey = true;\n        }\n    }\n\n    if (!(\"bubbles\" in eventAttrs)) {\n        eventAttrs.bubbles = true;\n    }\n\n    const [keydownEvent, keyupEvent] = await triggerEvents(\n        document.activeElement,\n        null,\n        [\n            [\"keydown\", eventAttrs],\n            [\"keyup\", eventAttrs],\n        ],\n        { skipVisibilityCheck: true }\n    );\n\n    return { keydownEvent, keyupEvent };\n}\n\nexport function mockDownload(cb) {\n    patchWithCleanup(download, { _download: cb });\n}\n\nexport const hushConsole = Object.create(null);\nfor (const propName of Object.keys(window.console)) {\n    hushConsole[propName] = () => {};\n}\n\nexport function mockSendBeacon(mock) {\n    patchWithCleanup(navigator, {\n        sendBeacon: (url, blob) => {\n            return mock(url, blob) !== false;\n        },\n    });\n}\n\nexport function mockTimeout() {\n    const timeouts = new Map();\n    let currentTime = 0;\n    let id = 1;\n    patchWithCleanup(browser, {\n        setTimeout(fn, delay = 0) {\n            timeouts.set(id, { fn, scheduledFor: delay + currentTime, id });\n            return id++;\n        },\n        clearTimeout(id) {\n            timeouts.delete(id);\n        },\n    });\n    return {\n        execRegisteredTimeouts() {\n            for (const { fn } of timeouts.values()) {\n                fn();\n            }\n            timeouts.clear();\n        },\n        async advanceTime(duration) {\n            // wait here so all microtasktick scheduled in this frame can be\n            // executed and possibly register their own timeout\n            await nextTick();\n            currentTime += duration;\n            for (const { fn, scheduledFor, id } of timeouts.values()) {\n                if (scheduledFor <= currentTime) {\n                    fn();\n                    timeouts.delete(id);\n                }\n            }\n            // wait here to make sure owl can update the UI\n            await nextTick();\n        },\n    };\n}\n\nexport function mockAnimationFrame() {\n    const callbacks = new Map();\n    let currentTime = 0;\n    let id = 1;\n    patchWithCleanup(browser, {\n        requestAnimationFrame(fn) {\n            callbacks.set(id, { fn, scheduledFor: 16 + currentTime, id });\n            return id++;\n        },\n        cancelAnimationFrame(id) {\n            callbacks.delete(id);\n        },\n        performance: { now: () => currentTime },\n    });\n    return {\n        execRegisteredAnimationFrames() {\n            for (const { fn } of callbacks.values()) {\n                fn(currentTime);\n            }\n            callbacks.clear();\n        },\n        async advanceFrame(count = 1) {\n            // wait here so all microtasktick scheduled in this frame can be\n            // executed and possibly register their own timeout\n            await nextTick();\n            currentTime += 16 * count;\n            for (const { fn, scheduledFor, id } of callbacks.values()) {\n                if (scheduledFor <= currentTime) {\n                    fn(currentTime);\n                    callbacks.delete(id);\n                }\n            }\n            // wait here to make sure owl can update the UI\n            await nextTick();\n        },\n    };\n}\n\nexport async function mount(Comp, target, config = {}) {\n    let { props, env } = config;\n    env = env || {};\n    const configuration = {\n        env,\n        templates,\n        test: true,\n        props,\n    };\n    if (env.services && \"localization\" in env.services) {\n        configuration.translateFn = _t;\n    }\n    const app = new App(Comp, configuration);\n    registerCleanup(() => app.destroy());\n    return app.mount(target);\n}\n\nexport function destroy(comp) {\n    comp.__owl__.app.destroy();\n}\n\nexport function findChildren(comp, predicate = (e) => e) {\n    const queue = [];\n    [].unshift.apply(queue, Object.values(comp.__owl__.children));\n\n    while (queue.length > 0) {\n        const curNode = queue.pop();\n        if (predicate(curNode)) {\n            return curNode;\n        }\n        [].unshift.apply(queue, Object.values(curNode.component.__owl__.children));\n    }\n}\n\n// partial replacement of t-ref on component\nexport function useChild() {\n    const node = useComponent().__owl__;\n    const setChild = () => {\n        const componentNode = Object.values(node.children)[0];\n        node.component.child = componentNode.component;\n    };\n    onMounted(setChild);\n    onPatched(setChild);\n}\n\nexport function useLogLifeCycle(logFn, name = \"\") {\n    const component = useComponent();\n    let loggedName = `${component.constructor.name}`;\n    if (name) {\n        loggedName = `${component.constructor.name} ${name}`;\n    }\n    onError(() => {\n        logFn(`onError ${loggedName}`);\n    });\n    onMounted(() => {\n        logFn(`onMounted ${loggedName}`);\n    });\n    onPatched(() => {\n        logFn(`onPatched ${loggedName}`);\n    });\n    onRendered(() => {\n        logFn(`onRendered ${loggedName}`);\n    });\n    onWillDestroy(() => {\n        logFn(`onWillDestroy ${loggedName}`);\n    });\n    onWillPatch(() => {\n        logFn(`onWillPatch ${loggedName}`);\n    });\n    onWillRender(() => {\n        logFn(`onWillRender ${loggedName}`);\n    });\n    onWillStart(() => {\n        logFn(`onWillStart ${loggedName}`);\n    });\n    onWillUnmount(() => {\n        logFn(`onWillUnmount ${loggedName}`);\n    });\n    onWillUpdateProps(() => {\n        logFn(`onWillUpdateProps ${loggedName}`);\n    });\n}\n\n/**\n * Returns the list of nodes containing n2 (included) that do not contain n1.\n *\n * @param {Node} n1\n * @param {Node} n2\n * @returns {Node[]}\n */\nfunction getDifferentParents(n1, n2) {\n    const parents = [n2];\n    while (parents[0].parentNode) {\n        const parent = parents[0].parentNode;\n        if (parent.contains(n1)) {\n            break;\n        }\n        parents.unshift(parent);\n    }\n    return parents;\n}\n\n/**\n * Helper performing a drag and drop sequence.\n *\n * - 'from' is used to determine the element on which the drag will start;\n * - 'target' will determine the element on which the first one will be dropped.\n *\n * The first element will be dragged by its center, and will be dropped on the\n * bottom-right inner pixel of the target element. This behavior covers both\n * cases of appending the first element to the end of a list (toSelector =\n * target list) or moving it at the position of another element, effectively\n * placing the first element before the second (toSelector = other element).\n *\n * A position can be given to drop the first element above, below, or on the\n * side of the second (default is inside, as specified above).\n *\n * Note that only the last event is awaited, since all the others are\n * considered to be synchronous.\n *\n * @param {Element | string} from\n * @param {Element | string} to\n * @param {Position} [position]\n */\nexport async function dragAndDrop(from, to, position) {\n    const { drop } = await drag(from);\n    await drop(to, position);\n}\n\n/**\n * Helper performing a drag.\n *\n * - the 'from' selector is used to determine the element on which the drag will\n *  start;\n * - the 'target' selector will determine the element on which the dragged element will be\n * moved.\n *\n * Returns a drop function\n *\n * @param {Element | string} from\n */\nexport async function drag(from, pointerType = \"mouse\") {\n    const assertIsDragging = (fn, endDrag) => {\n        return {\n            async [fn.name](...args) {\n                if (dragEndReason) {\n                    throw new Error(\n                        `Cannot execute drag helper '${fn.name}': drag sequence has been ended by '${dragEndReason}'.`\n                    );\n                }\n                await fn(...args);\n                if (endDrag) {\n                    dragEndReason = fn.name;\n                }\n            },\n        }[fn.name];\n    };\n\n    const cancel = assertIsDragging(async function cancel() {\n        await triggerEvent(window, null, \"keydown\", { key: \"Escape\" });\n    }, true);\n\n    /**\n     * @param {Element | string} [to]\n     * @param {Position} [position]\n     */\n    const drop = assertIsDragging(async function drop(to, position) {\n        if (to) {\n            await moveTo(to, position);\n        }\n        await triggerEvent(target || source, null, \"pointerup\", targetPosition);\n    }, true);\n\n    /**\n     * @param {Element | string} selector\n     */\n    const getEl = (selector) =>\n        selector instanceof Element ? selector : fixture.querySelector(selector);\n\n    /**\n     * @param {Position} [position]\n     */\n    const getTargetPosition = (position) => {\n        const tRect = target.getBoundingClientRect();\n        const tPos = {\n            clientX: Math.floor(tRect.x),\n            clientY: Math.floor(tRect.y),\n        };\n        if (position && typeof position === \"object\") {\n            // x and y coordinates start from the element's initial coordinates\n            tPos.clientX += position.x || 0;\n            tPos.clientY += position.y || 0;\n        } else {\n            const positions = typeof position === \"string\" ? position.split(\"-\") : [];\n\n            // X position\n            if (positions.includes(\"left\")) {\n                tPos.clientX -= 1;\n            } else if (positions.includes(\"right\")) {\n                tPos.clientX += Math.ceil(tRect.width) + 1;\n            } else {\n                tPos.clientX += Math.floor(tRect.width / 2);\n            }\n\n            // Y position\n            if (positions.includes(\"top\")) {\n                tPos.clientY -= 1;\n            } else if (positions.includes(\"bottom\")) {\n                tPos.clientY += Math.ceil(tRect.height) + 1;\n            } else {\n                tPos.clientY += Math.floor(tRect.height / 2);\n            }\n        }\n        return tPos;\n    };\n\n    /**\n     * @param {Element | string} [to]\n     * @param {Position} [position]\n     */\n    const moveTo = assertIsDragging(async function moveTo(to, position) {\n        target = getEl(to);\n        if (!target) {\n            return;\n        }\n\n        // Recompute target position\n        targetPosition = getTargetPosition(position);\n\n        // Move, enter and drop the element on the target\n        await triggerEvent(source, null, \"pointermove\", targetPosition);\n\n        // \"pointerenter\" is fired on every parent of `target` that do not contain\n        // `from` (typically: different parent lists).\n        for (const parent of getDifferentParents(source, target)) {\n            triggerEvent(parent, null, \"pointerenter\", targetPosition);\n        }\n        await nextTick();\n\n        return dragHelpers;\n    }, false);\n\n    const dragHelpers = { cancel, drop, moveTo };\n    const fixture = getFixture();\n\n    const source = getEl(from instanceof Element ? from : fixture.querySelector(from));\n    const sourceRect = source.getBoundingClientRect();\n\n    let dragEndReason = null;\n    let target;\n    let targetPosition;\n\n    // Pointer down on main target\n    await triggerEvent(source, null, \"pointerdown\", {\n        pointerType,\n        clientX: sourceRect.x + sourceRect.width / 2,\n        clientY: sourceRect.y + sourceRect.height / 2,\n    });\n\n    return dragHelpers;\n}\n\nexport async function clickDropdown(target, fieldName) {\n    const dropdownInput = target.querySelector(`[name='${fieldName}'] .dropdown input`);\n    dropdownInput.focus();\n    await nextTick();\n    await click(dropdownInput);\n}\n\nexport async function clickOpenedDropdownItem(target, fieldName, itemContent) {\n    const dropdowns = target.querySelectorAll(`[name='${fieldName}'] .dropdown .dropdown-menu`);\n    if (dropdowns.length === 0) {\n        throw new Error(`No dropdown found for field ${fieldName}`);\n    } else if (dropdowns.length > 1) {\n        throw new Error(`Found ${dropdowns.length} dropdowns for field ${fieldName}`);\n    }\n    const dropdownItems = dropdowns[0].querySelectorAll(\"li\");\n    const indexToClick = Array.from(dropdownItems)\n        .map((html) => html.textContent)\n        .indexOf(itemContent);\n    if (indexToClick === -1) {\n        throw new Error(`The element '${itemContent}' does not exist in the dropdown`);\n    }\n    await click(dropdownItems[indexToClick]);\n}\n\nexport async function selectDropdownItem(target, fieldName, itemContent) {\n    await clickDropdown(target, fieldName);\n    await clickOpenedDropdownItem(target, fieldName, itemContent);\n}\n\nexport function getNodesTextContent(nodes) {\n    return Array.from(nodes).map((n) => n.textContent);\n}\n\n/**\n * Click to open the dropdown on a many2one\n */\nexport async function clickOpenM2ODropdown(el, fieldName, selector) {\n    const m2oSelector = `${selector || \"\"} .o_field_many2one[name=${fieldName}] input`;\n    const matches = el.querySelectorAll(m2oSelector);\n    if (matches.length !== 1) {\n        throw new Error(\n            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`\n        );\n    }\n\n    await click(matches[0]);\n    return matches[0];\n}\n\n/**\n * Click on the active (highlighted) selection in a m2o dropdown.\n */\n// TO FIX\nexport async function clickM2OHighlightedItem(el, fieldName, selector) {\n    const m2oSelector = `${selector || \"\"} .o_field_many2one[name=${fieldName}] input`;\n    // const $dropdown = $(m2oSelector).autocomplete('widget');\n    const matches = el.querySelectorAll(m2oSelector);\n    if (matches.length !== 1) {\n        throw new Error(\n            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`\n        );\n    }\n    // clicking on an li (no matter which one), will select the focussed one\n    return click(matches[0].parentElement.querySelector(\"li\"));\n}\n\n// X2Many\nexport async function addRow(target, selector) {\n    await click(target.querySelector(`${selector ? selector : \"\"} .o_field_x2many_list_row_add a`));\n}\n\nexport async function removeRow(target, index) {\n    await click(target.querySelectorAll(\".o_list_record_remove\")[index]);\n}\n", "/* @odoo-module */\n\nimport { isVisible } from \"@web/core/utils/ui\";\nimport { registerCleanup } from \"@web/../tests/helpers/cleanup\";\nimport {\n    click as webClick,\n    getFixture,\n    makeDeferred,\n    triggerEvents as webTriggerEvents,\n} from \"@web/../tests/helpers/utils\";\n\n/**\n * Create a file object, which can be used for drag-and-drop.\n *\n * @param {Object} data\n * @param {string} data.name\n * @param {string} data.content\n * @param {string} data.contentType\n * @returns {Promise<Object>} resolved with file created\n */\nexport function createFile(data) {\n    // Note: this is only supported by Chrome, and does not work in Incognito mode\n    return new Promise(function (resolve, reject) {\n        var requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;\n        if (!requestFileSystem) {\n            throw new Error(\"FileSystem API is not supported\");\n        }\n        requestFileSystem(window.TEMPORARY, 1024 * 1024, function (fileSystem) {\n            fileSystem.root.getFile(data.name, { create: true }, function (fileEntry) {\n                fileEntry.createWriter(function (fileWriter) {\n                    fileWriter.onwriteend = function (e) {\n                        fileSystem.root.getFile(data.name, {}, function (fileEntry) {\n                            fileEntry.file(function (file) {\n                                resolve(file);\n                            });\n                        });\n                    };\n                    fileWriter.write(new Blob([data.content], { type: data.contentType }));\n                });\n            });\n        });\n    });\n}\n\n/**\n * Create a fake object 'dataTransfer', linked to some files,\n * which is passed to drag and drop events.\n *\n * @param {Object[]} files\n * @returns {Object}\n */\nfunction createFakeDataTransfer(files) {\n    return {\n        dropEffect: \"all\",\n        effectAllowed: \"all\",\n        files,\n        items: [],\n        types: [\"Files\"],\n    };\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then clicks on it.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options] forwarded to `contains`\n * @param {boolean} [options.shiftKey]\n */\nexport async function click(selector, options = {}) {\n    const { shiftKey } = options;\n    delete options.shiftKey;\n    await contains(selector, { click: { shiftKey }, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then dragenters `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dragenterFiles(selector, files, options) {\n    await contains(selector, { dragenterFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then dragovers `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dragoverFiles(selector, files, options) {\n    await contains(selector, { dragoverFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then drops `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dropFiles(selector, files, options) {\n    await contains(selector, { dropFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then inputs `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function inputFiles(selector, files, options) {\n    await contains(selector, { inputFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then pastes `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function pasteFiles(selector, files, options) {\n    await contains(selector, { pasteFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then focuses on it.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function focus(selector, options) {\n    await contains(selector, { setFocus: true, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then inserts the given `content`.\n *\n * @param {string} selector\n * @param {string} content\n * @param {ContainsOptions} [options] forwarded to `contains`\n * @param {boolean} [options.replace=false]\n */\nexport async function insertText(selector, content, options = {}) {\n    const { replace = false } = options;\n    delete options.replace;\n    await contains(selector, { ...options, insertText: { content, replace } });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then sets its `scrollTop` to the given value.\n *\n * @param {string} selector\n * @param {number|\"bottom\"} scrollTop\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function scroll(selector, scrollTop, options) {\n    await contains(selector, { setScroll: scrollTop, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then triggers `event` on it.\n *\n * @param {string} selector\n * @param {(import(\"@web/../tests/helpers/utils\").EventType|[import(\"@web/../tests/helpers/utils\").EventType, EventInit])[]} events\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function triggerEvents(selector, events, options) {\n    await contains(selector, { triggerEvents: events, ...options });\n}\n\nfunction log(ok, message) {\n    if (window.QUnit) {\n        QUnit.assert.ok(ok, message);\n    } else {\n        if (ok) {\n            console.log(message);\n        } else {\n            console.error(message);\n        }\n    }\n}\n\nlet hasUsedContainsPositively = false;\nif (window.QUnit) {\n    QUnit.testStart(() => (hasUsedContainsPositively = false));\n}\n/**\n * @typedef {[string, ContainsOptions]} ContainsTuple tuple representing params of the contains\n *  function, where the first element is the selector, and the second element is the options param.\n * @typedef {Object} ContainsOptions\n * @property {ContainsTuple} [after] if provided, the found element(s) must be after the element\n *  matched by this param.\n * @property {ContainsTuple} [before] if provided, the found element(s) must be before the element\n *  matched by this param.\n * @property {Object} [click] if provided, clicks on the first found element\n * @property {ContainsTuple|ContainsTuple[]} [contains] if provided, the found element(s) must\n *  contain the provided sub-elements.\n * @property {number} [count=1] numbers of elements to be found to declare the contains check\n *  as successful. Elements are counted after applying all other filters.\n * @property {Object[]} [dragenterFiles] if provided, dragenters the given files on the found element\n * @property {Object[]} [dragoverFiles] if provided, dragovers the given files on the found element\n * @property {Object[]} [dropFiles] if provided, drops the given files on the found element\n * @property {Object[]} [inputFiles] if provided, inputs the given files on the found element\n * @property {{content:string, replace:boolean}} [insertText] if provided, adds to (or replace) the\n *  value of the first found element by the given content.\n * @property {ContainsTuple} [parent] if provided, the found element(s) must have as\n *  parent the node matching the parent parameter.\n * @property {Object[]} [pasteFiles] if provided, pastes the given files on the found element\n * @property {number|\"bottom\"} [scroll] if provided, the scrollTop of the found element(s)\n *  must match.\n *  Note: when using one of the scrollTop options, it is advised to ensure the height is not going\n *  to change soon, by checking with a preceding contains that all the expected elements are in DOM.\n * @property {boolean} [setFocus] if provided, focuses the first found element.\n * @property {boolean} [shadowRoot] if provided, targets the shadowRoot of the found elements.\n * @property {number|\"bottom\"} [setScroll] if provided, sets the scrollTop on the first found\n *  element.\n * @property {HTMLElement} [target=getFixture()]\n * @property {string[]} [triggerEvents] if provided, triggers the given events on the found element\n * @property {string} [text] if provided, the textContent of the found element(s) or one of their\n *  descendants must match. Use `textContent` option for a match on the found element(s) only.\n * @property {string} [textContent] if provided, the textContent of the found element(s) must match.\n *  Prefer `text` option for a match on the found element(s) or any of their descendants, usually\n *  allowing for a simpler and less specific selector.\n * @property {string} [value] if provided, the input value of the found element(s) must match.\n *  Note: value changes are not observed directly, another mutation must happen to catch them.\n * @property {boolean} [visible] if provided, the found element(s) must be (in)visible\n */\nclass Contains {\n    /**\n     * @param {string} selector\n     * @param {ContainsOptions} [options={}]\n     */\n    constructor(selector, options = {}) {\n        this.selector = selector;\n        this.options = options;\n        this.options.count ??= 1;\n        this.options.targetParam = this.options.target;\n        this.options.target ??= getFixture();\n        let selectorMessage = `${this.options.count} of \"${this.selector}\"`;\n        if (this.options.visible !== undefined) {\n            selectorMessage = `${selectorMessage} ${\n                this.options.visible ? \"visible\" : \"invisible\"\n            }`;\n        }\n        if (this.options.targetParam) {\n            selectorMessage = `${selectorMessage} inside a specific target`;\n        }\n        if (this.options.parent) {\n            selectorMessage = `${selectorMessage} inside a specific parent`;\n        }\n        if (this.options.contains) {\n            selectorMessage = `${selectorMessage} with a specified sub-contains`;\n        }\n        if (this.options.text !== undefined) {\n            selectorMessage = `${selectorMessage} with text \"${this.options.text}\"`;\n        }\n        if (this.options.textContent !== undefined) {\n            selectorMessage = `${selectorMessage} with textContent \"${this.options.textContent}\"`;\n        }\n        if (this.options.value !== undefined) {\n            selectorMessage = `${selectorMessage} with value \"${this.options.value}\"`;\n        }\n        if (this.options.scroll !== undefined) {\n            selectorMessage = `${selectorMessage} with scroll \"${this.options.scroll}\"`;\n        }\n        if (this.options.after !== undefined) {\n            selectorMessage = `${selectorMessage} after a specified element`;\n        }\n        if (this.options.before !== undefined) {\n            selectorMessage = `${selectorMessage} before a specified element`;\n        }\n        this.selectorMessage = selectorMessage;\n        if (this.options.contains && !Array.isArray(this.options.contains[0])) {\n            this.options.contains = [this.options.contains];\n        }\n        if (this.options.count) {\n            hasUsedContainsPositively = true;\n        } else if (!hasUsedContainsPositively) {\n            throw new Error(\n                `Starting a test with \"contains\" of count 0 for selector \"${this.selector}\" is useless because it might immediately resolve. Start the test by checking that an expected element actually exists.`\n            );\n        }\n        /** @type {string} */\n        this.successMessage = undefined;\n        /** @type {function} */\n        this.executeError = undefined;\n    }\n\n    /**\n     * Starts this contains check, either immediately resolving if there is a\n     * match, or registering appropriate listeners and waiting until there is a\n     * match or a timeout (resolving or rejecting respectively).\n     *\n     * Success or failure messages will be logged with QUnit as well.\n     *\n     * @returns {Promise}\n     */\n    run() {\n        this.done = false;\n        this.def = makeDeferred();\n        this.scrollListeners = new Set();\n        this.onScroll = () => this.runOnce(\"after scroll\");\n        if (!this.runOnce(\"immediately\")) {\n            this.timer = setTimeout(\n                () => this.runOnce(\"Timeout of 5 seconds\", { crashOnFail: true }),\n                5000\n            );\n            this.observer = new MutationObserver((mutations) => {\n                try {\n                    this.runOnce(\"after mutations\");\n                } catch (e) {\n                    this.def.reject(e); // prevents infinite loop in case of programming error\n                }\n            });\n            this.observer.observe(this.options.target, {\n                attributes: true,\n                childList: true,\n                subtree: true,\n            });\n            registerCleanup(() => {\n                if (!this.done) {\n                    this.runOnce(\"Test ended\", { crashOnFail: true });\n                }\n            });\n        }\n        return this.def;\n    }\n\n    /**\n     * Runs this contains check once, immediately returning the result (or\n     * undefined), and possibly resolving or rejecting the main promise\n     * (and printing QUnit log) depending on options.\n     * If undefined is returned it means the check was not successful.\n     *\n     * @param {string} whenMessage\n     * @param {Object} [options={}]\n     * @param {boolean} [options.crashOnFail=false]\n     * @param {boolean} [options.executeOnSuccess=true]\n     * @returns {HTMLElement[]|undefined}\n     */\n    runOnce(whenMessage, { crashOnFail = false, executeOnSuccess = true } = {}) {\n        const res = this.select();\n        if (res?.length === this.options.count || crashOnFail) {\n            // clean before doing anything else to avoid infinite loop due to side effects\n            this.observer?.disconnect();\n            clearTimeout(this.timer);\n            for (const el of this.scrollListeners ?? []) {\n                el.removeEventListener(\"scroll\", this.onScroll);\n            }\n            this.done = true;\n        }\n        if (res?.length === this.options.count) {\n            this.successMessage = `Found ${this.selectorMessage} (${whenMessage})`;\n            if (executeOnSuccess) {\n                this.executeAction(res[0]);\n            }\n            return res;\n        } else {\n            this.executeError = () => {\n                let message = `Failed to find ${this.selectorMessage} (${whenMessage}).`;\n                message = res\n                    ? `${message} Found ${res.length} instead.`\n                    : `${message} Parent not found.`;\n                if (this.parentContains) {\n                    if (this.parentContains.successMessage) {\n                        log(true, this.parentContains.successMessage);\n                    } else {\n                        this.parentContains.executeError();\n                    }\n                }\n                log(false, message);\n                this.def?.reject(new Error(message));\n                for (const childContains of this.childrenContains || []) {\n                    if (childContains.successMessage) {\n                        log(true, childContains.successMessage);\n                    } else {\n                        childContains.executeError();\n                    }\n                }\n            };\n            if (crashOnFail) {\n                this.executeError();\n            }\n        }\n    }\n\n    /**\n     * Executes the action(s) given to this constructor on the found element,\n     * prints the success messages, and resolves the main deferred.\n\n     * @param {HTMLElement} el\n     */\n    executeAction(el) {\n        let message = this.successMessage;\n        if (this.options.click) {\n            message = `${message} and clicked it`;\n            webClick(el, undefined, {\n                mouseEventInit: this.options.click,\n                skipDisabledCheck: true,\n                skipVisibilityCheck: true,\n            });\n        }\n        if (this.options.dragenterFiles) {\n            message = `${message} and dragentered ${this.options.dragenterFiles.length} file(s)`;\n            const ev = new Event(\"dragenter\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dragenterFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.dragoverFiles) {\n            message = `${message} and dragovered ${this.options.dragoverFiles.length} file(s)`;\n            const ev = new Event(\"dragover\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dragoverFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.dropFiles) {\n            message = `${message} and dropped ${this.options.dropFiles.length} file(s)`;\n            const ev = new Event(\"drop\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dropFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.inputFiles) {\n            message = `${message} and inputted ${this.options.inputFiles.length} file(s)`;\n            // could not use _createFakeDataTransfer as el.files assignation will only\n            // work with a real FileList object.\n            const dataTransfer = new window.DataTransfer();\n            for (const file of this.options.inputFiles) {\n                dataTransfer.items.add(file);\n            }\n            el.files = dataTransfer.files;\n            /**\n             * Changing files programatically is not supposed to trigger the event but\n             * it does in Chrome versions before 73 (which is on runbot), so in that\n             * case there is no need to make a manual dispatch, because it would lead to\n             * the files being added twice.\n             */\n            const versionRaw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n            const chromeVersion = versionRaw ? parseInt(versionRaw[2], 10) : false;\n            if (!chromeVersion || chromeVersion >= 73) {\n                el.dispatchEvent(new Event(\"change\"));\n            }\n        }\n        if (this.options.insertText !== undefined) {\n            message = `${message} and inserted text \"${this.options.insertText.content}\" (replace: ${this.options.insertText.replace})`;\n            el.focus();\n            if (this.options.insertText.replace) {\n                el.value = \"\";\n                el.dispatchEvent(new window.KeyboardEvent(\"keydown\", { key: \"Backspace\" }));\n                el.dispatchEvent(new window.KeyboardEvent(\"keyup\", { key: \"Backspace\" }));\n                el.dispatchEvent(new window.InputEvent(\"input\"));\n            }\n            for (const char of this.options.insertText.content) {\n                el.value += char;\n                el.dispatchEvent(new window.KeyboardEvent(\"keydown\", { key: char }));\n                el.dispatchEvent(new window.KeyboardEvent(\"keyup\", { key: char }));\n                el.dispatchEvent(new window.InputEvent(\"input\"));\n            }\n            el.dispatchEvent(new window.InputEvent(\"change\"));\n        }\n        if (this.options.pasteFiles) {\n            message = `${message} and pasted ${this.options.pasteFiles.length} file(s)`;\n            const ev = new Event(\"paste\", { bubbles: true });\n            Object.defineProperty(ev, \"clipboardData\", {\n                value: createFakeDataTransfer(this.options.pasteFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.setFocus) {\n            message = `${message} and focused it`;\n            el.focus();\n        }\n        if (this.options.setScroll !== undefined) {\n            message = `${message} and set scroll to \"${this.options.setScroll}\"`;\n            el.scrollTop =\n                this.options.setScroll === \"bottom\" ? el.scrollHeight : this.options.setScroll;\n        }\n        if (this.options.triggerEvents) {\n            message = `${message} and triggered \"${this.options.triggerEvents.join(\", \")}\" events`;\n            webTriggerEvents(el, null, this.options.triggerEvents, {\n                skipVisibilityCheck: true,\n            });\n        }\n        if (this.parentContains) {\n            log(true, this.parentContains.successMessage);\n        }\n        log(true, message);\n        for (const childContains of this.childrenContains) {\n            log(true, childContains.successMessage);\n        }\n        this.def?.resolve();\n    }\n\n    /**\n     * Returns the found element(s) according to this constructor setup.\n     * If undefined is returned it means the parent cannot be found\n     *\n     * @returns {HTMLElement[]|undefined}\n     */\n    select() {\n        const target = this.selectParent();\n        if (!target) {\n            return;\n        }\n        const baseRes = [...target.querySelectorAll(this.selector)]\n            .map((el) => (this.options.shadowRoot ? el.shadowRoot : el))\n            .filter((el) => el);\n        /** @type {Contains[]} */\n        this.childrenContains = [];\n        const res = baseRes.filter((el, currentIndex) => {\n            let condition =\n                (this.options.textContent === undefined ||\n                    el.textContent.trim() === this.options.textContent) &&\n                (this.options.value === undefined || el.value === this.options.value) &&\n                (this.options.scroll === undefined ||\n                    (this.options.scroll === \"bottom\"\n                        ? Math.abs(el.scrollHeight - el.clientHeight - el.scrollTop) <= 1\n                        : Math.abs(el.scrollTop - this.options.scroll) <= 1));\n            if (condition && this.options.text !== undefined) {\n                if (\n                    el.textContent.trim() !== this.options.text &&\n                    [...el.querySelectorAll(\"*\")].every(\n                        (el) => el.textContent.trim() !== this.options.text\n                    )\n                ) {\n                    condition = false;\n                }\n            }\n            if (condition && this.options.contains) {\n                for (const param of this.options.contains) {\n                    const childContains = new Contains(param[0], { ...param[1], target: el });\n                    if (\n                        !childContains.runOnce(`as child of el ${currentIndex + 1})`, {\n                            executeOnSuccess: false,\n                        })\n                    ) {\n                        condition = false;\n                    }\n                    this.childrenContains.push(childContains);\n                }\n            }\n            if (condition && this.options.visible !== undefined) {\n                if (isVisible(el) !== this.options.visible) {\n                    condition = false;\n                }\n            }\n            if (condition && this.options.after) {\n                const afterContains = new Contains(this.options.after[0], {\n                    ...this.options.after[1],\n                    target,\n                });\n                const afterEl = afterContains.runOnce(`as \"after\"`, {\n                    executeOnSuccess: false,\n                })?.[0];\n                if (\n                    !afterEl ||\n                    !(el.compareDocumentPosition(afterEl) & Node.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    condition = false;\n                }\n                this.childrenContains.push(afterContains);\n            }\n            if (condition && this.options.before) {\n                const beforeContains = new Contains(this.options.before[0], {\n                    ...this.options.before[1],\n                    target,\n                });\n                const beforeEl = beforeContains.runOnce(`as \"before\"`, {\n                    executeOnSuccess: false,\n                })?.[0];\n                if (\n                    !beforeEl ||\n                    !(el.compareDocumentPosition(beforeEl) & Node.DOCUMENT_POSITION_FOLLOWING)\n                ) {\n                    condition = false;\n                }\n                this.childrenContains.push(beforeContains);\n            }\n            return condition;\n        });\n        if (\n            this.options.scroll !== undefined &&\n            this.scrollListeners &&\n            baseRes.length === this.options.count &&\n            res.length !== this.options.count\n        ) {\n            for (const el of baseRes) {\n                if (!this.scrollListeners.has(el)) {\n                    this.scrollListeners.add(el);\n                    el.addEventListener(\"scroll\", this.onScroll);\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Returns the found element that should act as the target (parent) for the\n     * main selector.\n     * If undefined is returned it means the parent cannot be found.\n     *\n     * @returns {HTMLElement|undefined}\n     */\n    selectParent() {\n        if (this.options.parent) {\n            this.parentContains = new Contains(this.options.parent[0], {\n                ...this.options.parent[1],\n                target: this.options.target,\n            });\n            return this.parentContains.runOnce(`as parent`, { executeOnSuccess: false })?.[0];\n        }\n        return this.options.target;\n    }\n}\n\n/**\n * Waits until `count` elements matching the given `selector` are present in\n * `options.target`.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options]\n * @returns {Promise}\n */\nexport async function contains(selector, options) {\n    await new Contains(selector, options).run();\n}\n\nconst stepState = {\n    expectedSteps: null,\n    deferred: null,\n    timeout: null,\n    currentSteps: [],\n\n    clear() {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.deferred = null;\n        this.currentSteps = [];\n        this.expectedSteps = null;\n    },\n\n    check({ crashOnFail = false } = {}) {\n        const success =\n            this.expectedSteps.length === this.currentSteps.length &&\n            this.expectedSteps.every((s, i) => s === this.currentSteps[i]);\n        if (!success && !crashOnFail) {\n            return;\n        }\n        QUnit.config.current.assert.verifySteps(this.expectedSteps);\n        if (success) {\n            this.deferred.resolve();\n        } else {\n            this.deferred.reject(new Error(\"Steps do not match.\"));\n        }\n        this.clear();\n    },\n};\n\nif (window.QUnit) {\n    QUnit.testStart(() =>\n        registerCleanup(() => {\n            if (stepState.expectedSteps) {\n                stepState.check({ crashOnFail: true });\n            } else {\n                stepState.clear();\n            }\n        })\n    );\n}\n\n/**\n * Indicate the completion of a test step. This step must then be verified by\n * calling `assertSteps`.\n *\n * @param {string} step\n */\nexport function step(step) {\n    stepState.currentSteps.push(step);\n    QUnit.config.current.assert.step(step);\n    if (stepState.expectedSteps) {\n        stepState.check();\n    }\n}\n\n/**\n * Wait for the given steps to be executed or for the timeout to be reached.\n *\n * @param {string[]} steps\n */\nexport function assertSteps(steps) {\n    if (stepState.expectedSteps) {\n        stepState.check({ crashOnFail: true });\n    }\n    stepState.expectedSteps = steps;\n    stepState.deferred = makeDeferred();\n    stepState.timeout = setTimeout(() => stepState.check({ crashOnFail: true }), 2000);\n    stepState.check();\n    return stepState.deferred;\n}\n", "/* @odoo-module */\n\nimport { registry } from \"@web/core/registry\";\nimport { click, contains, createFile, inputFiles } from \"@web/../tests/utils\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_public_tour.js\", {\n    test: true,\n    steps: () => [\n        {\n            trigger: \".o-mail-DiscussPublic\",\n            extraTrigger: \".o-mail-Thread\",\n            run() {},\n        },\n        {\n            content: \"Check that we are on channel page\",\n            trigger: \".o-mail-Thread\",\n            run() {\n                if (!window.location.pathname.startsWith(\"/discuss/channel\")) {\n                    console.error(\"Channel secret token is still present in URL.\");\n                }\n                const { missing, failed, unloaded } = odoo.loader.findErrors();\n                if ([missing, failed, unloaded].some((arr) => arr.length)) {\n                    console.error(\n                        \"Couldn't load all JS modules.\",\n                        JSON.stringify({ missing, failed, unloaded })\n                    );\n                }\n                document.body.classList.add(\"o_discuss_channel_public_modules_loaded\");\n            },\n            extraTrigger: \".o_discuss_channel_public_modules_loaded\",\n        },\n        {\n            content: \"Wait for all modules loaded check in previous step\",\n            trigger: \".o_discuss_channel_public_modules_loaded\",\n            run() {},\n        },\n        {\n            content: \"Write something in composer\",\n            trigger: \".o-mail-Composer-input\",\n            run: \"text cheese\",\n        },\n        {\n            content: \"Add one file in composer\",\n            trigger: \".o-mail-Composer button[aria-label='Attach files']\",\n            async run() {\n                await inputFiles(\".o-mail-Composer-coreMain .o_input_file\", [\n                    await createFile({\n                        content: \"hello, world\",\n                        contentType: \"text/plain\",\n                        name: \"text.txt\",\n                    }),\n                ]);\n            },\n        },\n        {\n            content: \"Check the earlier provided attachment is listed\",\n            trigger: '.o-mail-AttachmentCard[title=\"text.txt\"]',\n            extra_trigger: \".o-mail-AttachmentCard:not(.o-isUploading)\", // waiting the attachment to be uploaded\n            run() {},\n        },\n        {\n            content: \"Send message\",\n            trigger: \".o-mail-Composer-send:enabled\",\n        },\n        {\n            content: \"Check message is shown\",\n            trigger: '.o-mail-Message-body:contains(\"cheese\")',\n            run() {},\n        },\n        {\n            content: \"Check message contains the attachment\",\n            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains(\"text.txt\")',\n            run() {},\n        },\n        {\n            content: \"Click on more menu\",\n            trigger: \".o-mail-Message [title='Expand']\",\n        },\n        {\n            content: \"Click on edit\",\n            trigger: \".o-mail-Message [title='Edit']\",\n        },\n        {\n            content: \"Edit message\",\n            trigger: \".o-mail-Message .o-mail-Composer-input\",\n            run: \"text vegetables\",\n        },\n        {\n            content: \"Add one more file in composer\",\n            trigger: \".o-mail-Message .o-mail-Composer button[aria-label='Attach files']\",\n            async run() {\n                inputFiles(\".o-mail-Message .o-mail-Composer-coreMain .o_input_file\", [\n                    await createFile({\n                        content: \"hello 2\",\n                        contentType: \"text/plain\",\n                        name: \"extra.txt\",\n                    }),\n                ]);\n            },\n        },\n        {\n            content: \"Check the earlier provided extra attachment is listed\",\n            trigger: '.o-mail-Message .o-mail-Composer .o-mail-AttachmentCard[title=\"extra.txt\"]',\n            extra_trigger:\n                \".o-mail-Message .o-mail-Composer .o-mail-AttachmentCard:not(.o-isUploading)\", // waiting the attachment to be uploaded\n            run() {},\n        },\n        {\n            content: \"Save edited message\",\n            trigger: \".o-mail-Message a:contains(save)\",\n        },\n        {\n            content: \"Check message is edited\",\n            trigger: '.o-mail-Message-body:contains(\"vegetables\")',\n            run() {},\n        },\n        {\n            content: \"Check edited message contains the first attachment\",\n            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains(\"text.txt\")',\n            run() {},\n        },\n        {\n            content: \"Check edited message contains the extra attachment\",\n            trigger: '.o-mail-Message .o-mail-AttachmentCard:contains(\"extra.txt\")',\n            async run() {\n                await click(\".o-mail-AttachmentCard-unlink\", {\n                    parent: [\".o-mail-AttachmentCard\", { text: \"extra.txt\" }],\n                });\n                await click(\".btn\", { text: \"Ok\", parent: [\".modal\", { text: \"Confirmation\" }] });\n                await contains(\".o-mail-AttachmentCard\", { text: \"extra.txt\", count: 0 });\n            },\n        },\n        {\n            content: \"Open search panel\",\n            trigger: \"button[title='Search Messages']\",\n        },\n        {\n            content: \"Search for the attachment name\",\n            trigger: \".o_searchview_input\",\n            run: \"text text.txt\",\n        },\n        {\n            content: \"Trigger the search\",\n            trigger: \"button[aria-label='Search button']\",\n        },\n        {\n            content: \"Check that searched message contains the attachment\",\n            trigger:\n                '.o-mail-SearchMessagesPanel .o-mail-Message .o-mail-AttachmentCard:contains(\"text.txt\")',\n            run() {},\n        },\n    ],\n});\n", "/* @odoo-module */\n\nimport { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_as_guest_tour.js\", {\n        test: true,\n        steps: () => [\n            {\n                content: \"Channel secret token has been hidden on welcome page\",\n                trigger: \".o-mail-WelcomePage\",\n                run() {\n                    if (!window.location.pathname.startsWith(\"/discuss/channel\")) {\n                        console.error(\"Channel secret token is still present in URL.\");\n                    }\n                },\n            },\n            {\n                content: \"Click join\",\n                trigger: \"button[title='Join Channel']\",\n                extraTrigger: \".o-mail-Thread\",\n            },\n            {\n                content: \"Check that we are on channel page\",\n                trigger: \".o-mail-Thread\",\n                run() {},\n            },\n        ],\n    });\n"], "file": "/web/assets/1/fb12849/mail.assets_discuss_public_test_tours.js", "sourceRoot": "../../../../"}